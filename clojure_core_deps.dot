digraph coredeps {"extends?" -> "boolean";
"var-set" -> "set";
"generate-class" -> "val";
"for" -> "chunk-buffer";
"emit-protocol" -> "list";
"bean" -> "cons";
"send" -> "defn";
"re-groups" -> "zero?";
"protected-final-methods" -> "fn";
"reverse" -> "defn";
"when-first" -> "vector?";
"->Vec" -> "empty";
"generate-proxy" -> "vals";
"proxy" -> "contains?";
"partition-by" -> "let";
"aset-char" -> "def-aset";
"reduce1" -> "seq";
"sync" -> "fn";
"pr" -> "apply";
"emit-extend-protocol" -> "fn";
"range" -> "<";
"aget" -> "apply";
"take-nth" -> "drop";
"fnext" -> "first";
"loop" -> "symbol?";
"to-array-2d" -> "inc";
"load-lib" -> "when";
"load-data-reader-file" -> "read";
"with-open" -> "cond";
"munge" -> "symbol?";
"mapcat" -> "map";
"emit-impl" -> "->";
"mk-am" -> "aget";
"println" -> "apply";
"get-proxy-class" -> "or";
"assert-args" -> "when";
"generate-interface" -> "seq";
"dissoc!" -> "defn";
"emit-impl" -> "cons";
"byte" -> "defn";
"load-lib" -> "load-all";
"->Vec" -> "==";
"parse-opts+specs" -> "map";
"doubles" -> "concat";
"vary-meta" -> "with-meta";
"binding" -> "list";
"ref-min-history" -> "ref";
"with-loading-context" -> "with-meta";
"merge-hash-collisions" -> "seq";
"check-valid-options" -> "hash-set";
"defmulti" -> "and";
"generate-interface" -> "add-annotations";
"->VecSeq" -> "count";
"drop" -> "rest";
">" -> "first";
"print-object" -> "defn-";
"nth" -> "defn";
"destructure" -> "inc";
"compare-and-set!" -> "atom";
"binding" -> "assert-args";
"check-cyclic-dependency" -> "cons";
"with-in-str" -> "with-open";
"string?" -> "instance?";
"load-lib" -> "alias";
"comp" -> "defn";
"-reset-methods" -> "let";
"ancestors" -> "get";
"->ArrayChunk" -> "loop";
"load-lib" -> "use";
"select-keys" -> "loop";
"bound-fn*" -> "get-thread-bindings";
"case" -> "str";
"ex-data" -> "when";
"doseq" -> "gensym";
"sort" -> "to-array";
"defmacro" -> "cons";
"not-empty" -> "when";
"cond" -> "second";
"map" -> "conj";
"emit-deftype*" -> "list";
"unchecked-subtract-int" -> "defn";
"take" -> "lazy-seq";
"cycle" -> "when-let";
"parse-opts+specs" -> "print-str";
"check-cyclic-dependency" -> "str";
"merge-hash-collisions" -> "filter";
"ex-info" -> "defn";
"defmethod" -> "fn";
"tree-seq" -> "cons";
"derive" -> "let";
"->Vec" -> "instance?";
"refer" -> "get";
"print-sequential" -> "not";
"check-valid-options" -> "keys";
"load-lib" -> "hash-map";
"maybe-min-hash" -> "shift-mask";
"->>" -> "with-meta";
"repeatedly" -> "lazy-seq";
"assert-valid-fdecl" -> "defn-";
"set" -> "defn";
"with-redefs" -> "concat";
"nary-inline" -> "seq";
"take-last" -> "drop";
"defrecord" -> "import";
"select-keys" -> "next";
"sort-by" -> "comp";
"with-redefs" -> "vector";
"get-proxy-class" -> "defn";
"build-positional-factory" -> "split-at";
"defrecord" -> "symbol";
"add-doc-and-meta" -> "assoc";
"complement" -> "fn";
"count" -> "defn";
"nthrest" -> "seq";
"for" -> "gensym";
"emit-extend-type" -> "mapcat";
"deref" -> "deref-future";
"load-one" -> "root-resource";
"distinct" -> "fn";
"add-annotations" -> "defn-";
"keep-indexed" -> "when-not";
"for" -> "for";
"*3" -> "*3";
"load-data-readers" -> "load-data-readers";
"comp" -> "reverse";
"pref" -> "pref";
"unchecked-multiply" -> "unchecked-multiply";
"doseq" -> "doseq";
"bit-or" -> "bit-or";
"aset-byte" -> "aset-byte";
"if-not" -> "if-not";
"send-via" -> "send-via";
"hash-set" -> "hash-set";
"map" -> "chunk-cons";
"add-watch" -> "add-watch";
"unchecked-dec" -> "unchecked-dec";
"some" -> "some";
"nil?" -> "nil?";
"->VecSeq" -> "cons";
"string?" -> "string?";
"boolean-array" -> "boolean-array";
"second" -> "second";
"letfn" -> "letfn";
"keys" -> "keys";
"*2" -> "*2";
"long-array" -> "long-array";
"pop-thread-bindings" -> "pop-thread-bindings";
"check-valid-options" -> "check-valid-options";
"future-call" -> "binding-conveyor-fn";
"error-mode" -> "error-mode";
"cond" -> "cond";
"find-field" -> "str";
"bit-set" -> "bit-set";
"spit" -> "spit";
"find-protocol-method" -> "find-protocol-method";
"fn" -> "fn";
"sorted?" -> "sorted?";
"short-array" -> "short-array";
"ns-unalias" -> "ns-unalias";
"ns-publics" -> "ns-publics";
"EMPTY-NODE" -> "EMPTY-NODE";
"char-array" -> "char-array";
"dosync" -> "dosync";
"all-ns" -> "all-ns";
"long" -> "long";
"areduce" -> "alength";
"with-open" -> "with-open";
"generate-proxy" -> "+";
"init-proxy" -> "init-proxy";
"add-classpath" -> "add-classpath";
"false?" -> "false?";
"map-indexed" -> "chunk";
"await1" -> "await1";
"true?" -> "true?";
"gen-interface" -> "gen-interface";
"future" -> "concat";
"sync" -> "sync";
"validate-generate-class-options" -> "comp";
"emit-extend-protocol" -> "emit-extend-protocol";
"short" -> "short";
"ns-unmap" -> "ns-unmap";
"check-cyclic-dependency" -> "=";
"protected-final-methods" -> "protected-final-methods";
"repeat" -> "repeat";
"zipmap" -> "zipmap";
"distinct" -> "distinct";
"get-in" -> "get-in";
"bit-xor" -> "bit-xor";
"char-escape-string" -> "char-escape-string";
"complement" -> "complement";
"let" -> "let";
"get-validator" -> "get-validator";
"dotimes" -> "dotimes";
"ref-max-history" -> "ref-max-history";
"promise" -> "promise";
"defmethod" -> "defmethod";
"set-agent-send-executor!" -> "set-agent-send-executor!";
"destructure" -> "key";
"ns-aliases" -> "the-ns";
"nary-inline" -> "reduce1";
"protocol?" -> "protocol?";
"-'" -> "-'";
"pop!" -> "pop!";
"derive" -> "derive";
"assert-valid-fdecl" -> "seq";
"aset-float" -> "aset-float";
"valid-java-method-name" -> "valid-java-method-name";
"extend" -> "extend";
"-reset-methods" -> "-reset-methods";
"defmacro" -> "first";
"file-seq" -> "defn";
"lazy-cat" -> "lazy-cat";
"float?" -> "or";
"commute" -> "commute";
"intern" -> "ns";
"defstruct" -> "defstruct";
"->Vec" -> "some";
"unchecked-negate-int" -> "defn";
"with-in-str" -> "with-in-str";
"partition-by" -> "partition-by";
"rem" -> "rem";
"odd?" -> "odd?";
"symbol?" -> "symbol?";
"future" -> "vector";
"mapv" -> "mapv";
"*print-level*" -> "*print-level*";
"emit-method-builder" -> "apply";
"->Vec" -> "nil?";
"thread-bound?" -> "thread-bound?";
"*data-readers*" -> "*data-readers*";
"deref-future" -> "deref-future";
"root-resource" -> "root-resource";
"doto" -> "map";
"filterv" -> "filterv";
"filter" -> "seq";
"proxy-call-with-super" -> "proxy-call-with-super";
"ns-interns" -> "ns-interns";
"re-matches" -> "re-matches";
"split-with" -> "split-with";
"chunk-rest" -> "defn";
"munge" -> "munge";
"quot" -> "defn";
"loop" -> "loop";
"future-done?" -> "future-done?";
"take-nth" -> "lazy-seq";
"underive" -> "partition";
"spread" -> "spread";
"next" -> "next";
"unchecked-inc" -> "unchecked-inc";
"libspec?" -> "libspec?";
"import" -> "import";
"extend" -> "-reset-methods";
"print-meta" -> "print-meta";
"deliver" -> "deliver";
"symbol" -> "symbol";
"vals" -> "vals";
"spread" -> "next";
"select-keys" -> "select-keys";
"get-in" -> "let";
"re-matcher" -> "re-matcher";
"rand" -> "rand";
"deref" -> "deref";
"load-one" -> "load-one";
"amap" -> "<";
"distinct" -> "let";
"some->" -> "some->";
"with-out-str" -> "with-out-str";
"read" -> "read";
"sequence" -> "sequence";
"make-hierarchy" -> "make-hierarchy";
"+" -> "+";
"number?" -> "number?";
"assoc!" -> "assoc!";
"descendants" -> "descendants";
"generate-proxy" -> "generate-proxy";
"into-array" -> "into-array";
"last" -> "last";
"some-fn" -> "some-fn";
"unchecked-negate" -> "unchecked-negate";
"integer?" -> "integer?";
"defrecord" -> "defrecord";
"reduced?" -> "reduced?";
"emit-protocol" -> "meta";
"alter" -> "alter";
"prn" -> "prn";
"with-meta" -> "with-meta";
"floats" -> "floats";
"*" -> "*";
"emit-hinted-impl" -> "emit-hinted-impl";
"when-not" -> "when-not";
"butlast" -> "butlast";
"-" -> "-";
"->>" -> "->>";
"generate-proxy" -> "into-array";
"reversible?" -> "reversible?";
"rseq" -> "rseq";
"load-lib" -> "not";
"send-off" -> "send-off";
"when-let" -> "count";
"seq?" -> "seq?";
"refer-clojure" -> "refer-clojure";
"identical?" -> "identical?";
".." -> "..";
"print" -> "print";
"vary-meta" -> "vary-meta";
"doseq" -> "if-not";
"with-loading-context" -> "with-loading-context";
"agent-error" -> "agent-error";
"bit-flip" -> "bit-flip";
"zero?" -> "zero?";
"bit-and" -> "bit-and";
"load-data-reader-file" -> "load-data-reader-file";
"unquote-splicing" -> "unquote-splicing";
"future" -> "future";
"re-groups" -> "re-groups";
"newline" -> "newline";
"to-array-2d" -> "seq";
"protected-final-methods" -> "let";
"replicate" -> "replicate";
"keep-indexed" -> "keep-indexed";
"char?" -> "char?";
"maybe-min-hash" -> "apply";
"def-aset" -> "def-aset";
"distinct?" -> "distinct?";
"remove-ns" -> "remove-ns";
"ratio?" -> "ratio?";
"xml-seq" -> "xml-seq";
"vec" -> "vec";
"concat" -> "concat";
"update-in" -> "update-in";
"vector" -> "vector";
"future-call" -> "future-call";
"sigs" -> "sigs";
"print-dup" -> "class";
"with-bindings*" -> "with-bindings*";
"conj" -> "conj";
"bases" -> "bases";
"with-redefs" -> "with-redefs";
"root-directory" -> "root-directory";
"parse-opts+specs" -> "parse-opts";
"/" -> "/";
"dotimes" -> "long";
"unchecked-add" -> "unchecked-add";
"ref-set" -> "ref-set";
"assoc" -> "assoc";
"unchecked-remainder-int" -> "unchecked-remainder-int";
"numerator" -> "defn";
"seque" -> "seque";
"load-libs" -> "load-libs";
"aset-char" -> "aset-char";
"boolean" -> "boolean";
"read-string" -> "read-string";
"binding-conveyor-fn" -> "binding-conveyor-fn";
"neg?" -> "neg?";
"float-array" -> "float-array";
"doubles" -> "doubles";
"isa?" -> "isa?";
"counted?" -> "counted?";
"prefers" -> "defn";
"doto" -> "doto";
"extends?" -> "extends?";
"fits-table?" -> "fits-table?";
"remove-watch" -> "remove-watch";
"print-str" -> "print-str";
"*e" -> "*e";
"ref-history-count" -> "ref-history-count";
"rsubseq" -> "rsubseq";
"future?" -> "future?";
"vector?" -> "vector?";
"nthnext" -> "dec";
"prep-hashes" -> "prep-hashes";
"split-at" -> "split-at";
"chunk-cons" -> "chunk-cons";
"ns-refers" -> "ns-refers";
"create-struct" -> "create-struct";
"setup-reference" -> "setup-reference";
"proxy-super" -> "proxy-super";
"int-array" -> "int-array";
"unchecked-long" -> "unchecked-long";
"float" -> "float";
"mk-bound-fn" -> "mk-bound-fn";
"assert" -> "assert";
"map" -> "map";
"+'" -> "+'";
"add-doc-and-meta" -> "add-doc-and-meta";
"build-positional-factory" -> "build-positional-factory";
"memfn" -> "memfn";
"double-array" -> "double-array";
"ams" -> "ams";
"accessor" -> "accessor";
"-cache-protocol-fn" -> "class";
"sigs" -> "conj";
"pvalues" -> "seq";
"*print-length*" -> "*print-length*";
"frequencies" -> "frequencies";
"chars" -> "chars";
"class?" -> "class?";
"rand-int" -> "rand-int";
"*1" -> "*1";
"aset-short" -> "aset-short";
"load" -> "str";
"unchecked-short" -> "unchecked-short";
"prn-str" -> "prn-str";
"iterate" -> "iterate";
"chunk-append" -> "chunk-append";
"expand-method-impl-cache" -> "hash";
"emit-method-builder" -> "rest";
"when-first" -> "when-first";
"unchecked-double" -> "unchecked-double";
"parse-opts" -> "parse-opts";
"slurp" -> "slurp";
"restart-agent" -> "restart-agent";
"parse-opts+specs" -> "parse-opts+specs";
"unchecked-int" -> "unchecked-int";
"mapcat" -> "mapcat";
"hash-set" -> "keys";
"assoc-in" -> "assoc-in";
"get-thread-bindings" -> "get-thread-bindings";
"filter-methods" -> "filter-methods";
"bit-not" -> "bit-not";
"special-symbol?" -> "special-symbol?";
"ref" -> "ref";
"conj!" -> "conj!";
"case" -> "defmacro";
"find-var" -> "find-var";
"inc" -> "inc";
"future-cancel" -> "future-cancel";
"emit-extend-type" -> "emit-extend-type";
"every-pred" -> "every-pred";
"make-array" -> "type";
"definline" -> "definline";
"bound-fn*" -> "bound-fn*";
"default-data-readers" -> "default-data-readers";
"emit-method-builder" -> "keyword";
"unchecked-subtract" -> "unchecked-subtract";
"ns-name" -> "ns-name";
"shuffle" -> "shuffle";
"defn-" -> "defn-";
"re-find" -> "re-find";
"emit-extend-protocol" -> "let";
"print-dup" -> "print-dup";
"construct-proxy" -> "construct-proxy";
"ref-min-history" -> "ref-min-history";
"underive" -> "contains?";
"destructure" -> "destructure";
"seq" -> "seq";
"intern" -> "intern";
"unchecked-multiply-int" -> "unchecked-multiply-int";
"pvalues" -> "pvalues";
"add-annotations" -> "add-annotations";
"to-array-2d" -> "to-array-2d";
"sorted-map-by" -> "sorted-map-by";
"filter" -> "filter";
"*verbose-defrecords*" -> "*verbose-defrecords*";
"assert-valid-fdecl" -> "assert-valid-fdecl";
"*clojure-version*" -> "*clojure-version*";
"var?" -> "var?";
"alter-meta!" -> "alter-meta!";
"cond->" -> "list";
"unchecked-dec-int" -> "unchecked-dec-int";
"print-object" -> "print-object";
"comment" -> "comment";
"key" -> "key";
"gen-interface" -> "let";
"class" -> "class";
"re-seq" -> "re-seq";
"-cache-protocol-fn" -> "-cache-protocol-fn";
"ns" -> "ns";
"empty?" -> "empty?";
"test" -> "test";
"data-reader-urls" -> "data-reader-urls";
"create-ns" -> "create-ns";
"print-object" -> "class";
"merge-hash-collisions" -> "merge-hash-collisions";
"generate-interface" -> "generate-interface";
"name" -> "name";
"list?" -> "list?";
"reduce1" -> "reduce1";
"global-hierarchy" -> "global-hierarchy";
"dosync" -> "sync";
"destructure" -> "seq";
"escape-class-name" -> "escape-class-name";
"nthrest" -> "nthrest";
"->>" -> "seq?";
"nary-inline" -> "nary-inline";
"aset" -> "aset";
"nnext" -> "nnext";
"doall" -> "doall";
"extenders" -> "extenders";
"with-redefs-fn" -> "with-redefs-fn";
"macroexpand-1" -> "macroexpand-1";
"not-any?" -> "not-any?";
"resultset-seq" -> "resultset-seq";
"reductions" -> "reductions";
"pr-on" -> "pr-on";
"into" -> "into";
"with-precision" -> "with-precision";
"transient" -> "transient";
"gen-class" -> "into1";
"filter-key" -> "filter-key";
"ffirst" -> "ffirst";
"bit-clear" -> "bit-clear";
"proxy-name" -> "proxy-name";
"extend-type" -> "extend-type";
"load-reader" -> "load-reader";
"or" -> "or";
"hash" -> "hash";
"->VecSeq" -> "<";
"as->" -> "as->";
"def-aset" -> "concat";
"parents" -> "defn";
"inc'" -> "inc'";
"print-initialized" -> "print-initialized";
"expand-method-impl-cache" -> "expand-method-impl-cache";
"print-ctor" -> "print-ctor";
"=" -> "first";
"associative?" -> "associative?";
"float?" -> "float?";
"generate-interface" -> "name";
"drop-last" -> "drop-last";
"replace" -> "replace";
"decimal?" -> "decimal?";
"defn" -> "defn";
"parents" -> "parents";
"map?" -> "map?";
"prefers" -> "prefers";
"numerator" -> "numerator";
"condp" -> "condp";
"quot" -> "quot";
"chunk-rest" -> "chunk-rest";
"unchecked-negate-int" -> "unchecked-negate-int";
"file-seq" -> "file-seq";
"send" -> "send";
"with-local-vars" -> "with-local-vars";
"reverse" -> "reverse";
"validate-generate-class-options" -> "validate-generate-class-options";
"with-bindings" -> "with-bindings";
"count" -> "count";
"get-proxy-class" -> "get-proxy-class";
"set" -> "set";
"ex-info" -> "ex-info";
"bean" -> "first";
"unchecked-subtract-int" -> "unchecked-subtract-int";
"when-let" -> "when-let";
"comp" -> "comp";
"def-aset" -> "vector";
"nth" -> "nth";
"underive" -> "interpose";
"deftype" -> "methods";
"print-method" -> "get";
"byte" -> "byte";
"dissoc!" -> "dissoc!";
"implements?" -> "implements?";
"decimal?" -> "defn";
"ns-imports" -> "ns-imports";
"while" -> "while";
"constantly" -> "constantly";
"add-annotation" -> "str";
"load" -> "load";
"defn" -> "map?";
"namespace" -> "namespace";
"pr-str" -> "pr-str";
"<" -> "<";
"rationalize" -> "rationalize";
"sort-by" -> "sort-by";
"cycle" -> "cycle";
"peek" -> "peek";
"denominator" -> "denominator";
"find-field" -> "find-field";
"most-specific" -> "most-specific";
"reduce" -> "reduce";
"interleave" -> "interleave";
"print-map" -> "print-map";
"amap" -> "amap";
"->" -> "->";
"cons" -> "cons";
"macroexpand" -> "macroexpand";
"ctor-sigs" -> "ctor-sigs";
"var-set" -> "var-set";
"add-annotation" -> "add-annotation";
"str" -> "str";
"aset-boolean" -> "aset-boolean";
"emit-impl" -> "emit-impl";
"remove-all-methods" -> "remove-all-methods";
"first" -> "first";
"bean" -> "bean";
"=" -> "=";
"memoize" -> "memoize";
"doseq" -> "second";
"max-switch-table-size" -> "max-switch-table-size";
"mk-am" -> "aclone";
"var-get" -> "var-get";
"unchecked-float" -> "unchecked-float";
"range" -> "range";
"await-for" -> "agent";
"tree-seq" -> "tree-seq";
"defmacro" -> "defmacro";
"set-validator!" -> "set-validator!";
"replace" -> "defn";
"aset-double" -> "aset-double";
"check-cyclic-dependency" -> "check-cyclic-dependency";
"empty" -> "instance?";
"*'" -> "*'";
"case" -> "case";
"unchecked-divide-int" -> "unchecked-divide-int";
"drop-last" -> "defn";
"enumeration-seq" -> "enumeration-seq";
"prefer-method" -> "prefer-method";
"partition-all" -> "partition-all";
"ensure" -> "ensure";
"reduced" -> "reduced";
"find-ns" -> "find-ns";
"not-every?" -> "not-every?";
"struct-map" -> "struct-map";
"some->>" -> "list";
"drop" -> "dec";
">" -> ">";
"max" -> "max";
"proxy-mappings" -> "proxy-mappings";
"identity" -> "identity";
"*loaded-libs*" -> "*loaded-libs*";
"float?" -> "defn";
"ints" -> "ints";
"fnext" -> "fnext";
"biginteger" -> "biginteger";
"min-key" -> "min-key";
"fn?" -> "instance?";
"reset-meta!" -> "reset-meta!";
"array" -> "array";
"push-thread-bindings" -> "push-thread-bindings";
"unchecked-add-int" -> "unchecked-add-int";
"subs" -> "subs";
"compile" -> "compile";
"throw-if" -> "throw-if";
"agent-errors" -> "agent-errors";
"clear-agent-errors" -> "clear-agent-errors";
"printf" -> "printf";
"overload-name" -> "overload-name";
"ns-resolve" -> "ns-resolve";
"group-by" -> "group-by";
"line-seq" -> "lazy-seq";
"method-sig" -> "method-sig";
"*default-data-reader-fn*" -> "*default-data-reader-fn*";
">=" -> ">=";
"assert-same-protocol" -> "assert-same-protocol";
"shutdown-agents" -> "shutdown-agents";
"reduce-kv" -> "reduce-kv";
"empty?" -> "seq";
"reset!" -> "reset!";
"is-runtime-annotation?" -> "is-runtime-annotation?";
"merge-hash-collisions" -> "reduce1";
"case-map" -> "case-map";
"even?" -> "even?";
"require" -> "require";
"bit-shift-left" -> "bit-shift-left";
"prep-hashes" -> "map";
"dec'" -> "dec'";
"methods" -> "methods";
"future-cancelled?" -> "future-cancelled?";
"compare" -> "compare";
"deftype" -> "deftype";
"sorted-set-by" -> "sorted-set-by";
"cast" -> "cast";
"namespace-munge" -> "namespace-munge";
"supers" -> "supers";
"pcalls" -> "pcalls";
"load-string" -> "load-string";
"imap-cons" -> "imap-cons";
"get" -> "get";
"<=" -> "<=";
"await" -> "await";
"resolve" -> "resolve";
"bytes" -> "bytes";
"proxy" -> "apply";
"print-method" -> "print-method";
"bound?" -> "bound?";
"loaded-libs" -> "loaded-libs";
"fnil" -> "fnil";
"with-local-vars" -> "count";
"force" -> "force";
"partial" -> "partial";
"refer" -> "and";
"ns" -> "seq";
">1?" -> ">1?";
"pmap" -> "pmap";
"if-let" -> "if-let";
"comparator" -> "comparator";
"pos?" -> "pos?";
"prim->class" -> "prim->class";
"char" -> "char";
"take-while" -> "take-while";
"*loading-verbosely*" -> "*loading-verbosely*";
"extend-protocol" -> "extend-protocol";
"associative?" -> "defn";
"defrecord" -> "with-meta";
"sequential?" -> "instance?";
"chunk" -> "chunk";
"and" -> "and";
"refer" -> "refer";
"underive" -> "underive";
"iterator-seq" -> "iterator-seq";
"declare" -> "declare";
"ancestors" -> "ancestors";
"hash-combine" -> "hash-combine";
"pmap" -> "if-let";
"persistent!" -> "persistent!";
"with-open" -> "let";
"locking" -> "locking";
"partition" -> "partition";
"maybe-destructured" -> "maybe-destructured";
"defmulti" -> "apply";
"map-indexed" -> "map-indexed";
"contains?" -> "contains?";
"update-proxy" -> "update-proxy";
"shift-mask" -> "shift-mask";
"interpose" -> "interpose";
"aset-int" -> "aset-int";
"emit-method-builder" -> "emit-method-builder";
"print-ctor" -> "defn";
"ifn?" -> "ifn?";
"definterface" -> "definterface";
"deftype" -> "namespace-munge";
"group-by-sig" -> "group-by-sig";
"delay" -> "delay";
"apply" -> "apply";
"swap!" -> "swap!";
"defmulti" -> "defmulti";
"proxy" -> "proxy";
"into" -> "transient";
"reify" -> "reify";
"subvec" -> "subvec";
"byte-array" -> "byte-array";
"rest" -> "rest";
"assert-args" -> "list";
"keyword" -> "keyword";
"prependss" -> "prependss";
"*pending-paths*" -> "defonce";
"ns-map" -> "ns-map";
"set-error-mode!" -> "set-error-mode!";
"maybe-min-hash" -> "maybe-min-hash";
"unquote" -> "unquote";
"super-chain" -> "super-chain";
"int" -> "int";
"release-pending-sends" -> "release-pending-sends";
"mod" -> "mod";
"bigdec" -> "bigdec";
"nfirst" -> "nfirst";
"nthnext" -> "nthnext";
"descriptor" -> "descriptor";
"delay" -> "apply";
"aset-long" -> "aset-long";
"interleave" -> "cons";
"non-private-methods" -> "non-private-methods";
"print-sequential" -> "binding";
"struct" -> "struct";
"array-map" -> "array-map";
"unchecked-char" -> "unchecked-char";
"ns-publics" -> "fn";
"bigint" -> "bigint";
"dec" -> "dec";
"emit-hinted-impl" -> "vary-meta";
"println" -> "println";
"aget" -> "aget";
"emit-deftype*" -> "meta";
"find-keyword" -> "find-keyword";
"pr" -> "pr";
"drop" -> "drop";
"clojure-version" -> "clojure-version";
"line-seq" -> "line-seq";
"gen-class" -> "gen-class";
"eval" -> "eval";
"aclone" -> "aclone";
"char-name-string" -> "char-name-string";
"pop" -> "pop";
"primitives-classnames" -> "primitives-classnames";
"atom" -> "atom";
"defonce" -> "defonce";
"bit-shift-right" -> "bit-shift-right";
"*pending-paths*" -> "*pending-paths*";
"mk-am" -> "mk-am";
"delay?" -> "delay?";
"num" -> "num";
"realized?" -> "realized?";
"disj" -> "disj";
"emit-protocol" -> "alter-var-root";
"io!" -> "io!";
"rational?" -> "rational?";
"merge-with" -> "merge-with";
"take-nth" -> "take-nth";
"emit-impl" -> "first";
"emit-protocol" -> "merge";
"into1" -> "into1";
"the-class" -> "the-class";
"double" -> "double";
"lazy-seq" -> "lazy-seq";
"emit-defrecord" -> "emit-defrecord";
"inc'" -> "defn";
"rsubseq" -> "mk-bound-fn";
"take-last" -> "take-last";
"parse-impls" -> "drop-while";
"take" -> "take";
"unchecked-byte" -> "unchecked-byte";
"when" -> "when";
"load-all" -> "load-all";
"areduce" -> "areduce";
"set?" -> "set?";
"make-array" -> "make-array";
"rand-nth" -> "rand-nth";
"alias" -> "alias";
"use" -> "use";
"juxt" -> "juxt";
"alength" -> "alength";
"chunk-first" -> "chunk-first";
"defprotocol" -> "defprotocol";
"to-array" -> "to-array";
"hash-map" -> "hash-map";
"bit-and-not" -> "bit-and-not";
"assert-valid-fdecl" -> "empty?";
"compare-and-set!" -> "compare-and-set!";
"type" -> "type";
"repeatedly" -> "repeatedly";
"trampoline" -> "trampoline";
"set-error-handler!" -> "set-error-handler!";
"validate-fields" -> "validate-fields";
"not" -> "not";
"take" -> "when";
"remove" -> "remove";
"find" -> "find";
"coll?" -> "coll?";
"drop-while" -> "drop-while";
"parse-impls" -> "parse-impls";
"promise" -> "let";
"not-empty" -> "not-empty";
"flatten" -> "flatten";
"ex-data" -> "ex-data";
"set-agent-send-off-executor!" -> "set-agent-send-off-executor!";
"normalize-slurp-opts" -> "normalize-slurp-opts";
"println-str" -> "println-str";
"list" -> "list";
"get-super-and-interfaces" -> "get-super-and-interfaces";
"chunk-next" -> "chunk-next";
"every?" -> "every?";
"satisfies?" -> "satisfies?";
"flush" -> "flush";
"assert-args" -> "assert-args";
"load-lib" -> "load-lib";
"max-mask-bits" -> "max-mask-bits";
"some->>" -> "some->>";
"sort" -> "sort";
"prep-ints" -> "prep-ints";
"dissoc" -> "dissoc";
"cond->" -> "cond->";
"extend" -> "protocol?";
"binding" -> "binding";
"print-sequential" -> "print-sequential";
"error-handler" -> "error-handler";
"get-method" -> "get-method";
"agent" -> "agent";
"sorted-set" -> "sorted-set";
"alter-var-root" -> "alter-var-root";
"merge" -> "merge";
"subseq" -> "subseq";
"emit-protocol" -> "emit-protocol";
"min" -> "min";
"print-simple" -> "print-simple";
"bit-test" -> "bit-test";
"await-for" -> "await-for";
"keep" -> "keep";
"disj!" -> "disj!";
"meta" -> "meta";
"emit-deftype*" -> "emit-deftype*";
"sorted-map" -> "sorted-map";
"read-line" -> "read-line";
"re-pattern" -> "re-pattern";
"cond->>" -> "cond->>";
"keyword?" -> "keyword?";
"prep-hashes" -> "fits-table?";
"asm-type" -> "asm-type";
"system-newline" -> "system-newline";
"validate-fields" -> "when";
"unchecked-inc-int" -> "unchecked-inc-int";
"for" -> "second";
"val" -> "val";
"chunked-seq?" -> "chunked-seq?";
"find-protocol-impl" -> "find-protocol-impl";
"vector-of" -> "vector-of";
"definterface" -> "apply";
"object-array" -> "object-array";
"max-key" -> "max-key";
"list*" -> "list*";
"ns-aliases" -> "ns-aliases";
"hash" -> "defn";
"booleans" -> "booleans";
"the-ns" -> "the-ns";
"emit-extend-type" -> "defn-";
"==" -> "==";
"chunk-buffer" -> "chunk-buffer";
"generate-class" -> "generate-class";
"longs" -> "longs";
"process-annotation" -> "process-annotation";
"shorts" -> "shorts";
"data-reader-var" -> "data-reader-var";
"is-annotation?" -> "is-annotation?";
"instance?" -> "instance?";
">0?" -> ">0?";
"make-array" -> "alength";
"format" -> "format";
"ns" -> "filter";
"sequential?" -> "sequential?";
"fn?" -> "fn?";
"case" -> "=";
"empty" -> "empty";
"bound-fn" -> "bound-fn";
"repeatedly" -> "take";
"dorun" -> "dorun";
"time" -> "time";
"remove-method" -> "remove-method";
"dotimes" -> "let";
"gensym" -> "gensym";
"not=" -> "not=";
"floats" -> "concat";
"refer" -> "apply";
"macroexpand-1" -> "defn";
"->ArrayChunk" -> "+";
"and" -> "apply";
"definline" -> "seq";
"process-annotation" -> "doseq";
"with-local-vars" -> "interleave";
"case" -> ">";
"with-redefs-fn" -> "defn";
"->" -> "first";
"re-matches" -> "re-matcher";
"destructure" -> "nnext";
"reduce" -> "coll-reduce";
"load-reader" -> "defn";
"generate-proxy" -> "when-not";
"asm-type" -> "instance?";
"generate-class" -> "doseq";
"areduce" -> "list";
"->Vec" -> "EMPTY-NODE";
"map" -> "chunk-append";
"future" -> "future-call";
"proxy-name" -> "defn";
"replace" -> "count";
"keyword?" -> "instance?";
"doseq" -> "fn";
"fn" -> "let";
"load" -> "check-cyclic-dependency";
"build-positional-factory" -> "defn-";
"parents" -> "set";
"interleave" -> "first";
"re-pattern" -> "instance?";
"load-lib" -> "binding";
"read-line" -> "instance?";
"emit-extend-type" -> "seq";
"filter-methods" -> "defn-";
"while" -> "defmacro";
"with-loading-context" -> "concat";
"when" -> "list";
"with-loading-context" -> "vector";
"for" -> "cond";
"frequencies" -> "inc";
"find-field" -> "first";
"bit-clear" -> "defn";
"update-proxy" -> "proxy";
"bigdec" -> "double";
".." -> "concat";
"range" -> ">";
"re-groups" -> "conj";
"pcalls" -> "pmap";
"partition-by" -> "next";
"merge-with" -> "when";
"resultset-seq" -> "or";
"find-field" -> "=";
"println" -> "*print-readably*";
"parse-opts+specs" -> "defn-";
"io!" -> "when";
"the-ns" -> "instance?";
"disj" -> "when";
"emit-defrecord" -> "hash-map";
"transient" -> "defn";
"refer-clojure" -> "concat";
"validate-generate-class-options" -> "str";
"filter-key" -> "defn";
"->VecSeq" -> "first";
"parse-opts" -> "defn-";
"ns-name" -> "ns";
"load-data-readers" -> "fn";
"sorted-set-by" -> "comparator";
"<" -> "first";
"definline" -> "alter-meta!";
"for" -> "fn";
"->" -> "defmacro";
"intern" -> "name";
"chars" -> "definline";
"locking" -> "apply";
"munge" -> "symbol";
"assoc" -> "map";
"amap" -> "defmacro";
"letfn" -> "fn";
"->Vec" -> "cond";
"assert-same-protocol" -> "resolve";
"second" -> "fn";
"generate-proxy" -> "..";
"load" -> "first";
"keep" -> "chunked-seq?";
"drop" -> "lazy-seq";
"emit-protocol" -> "keyword?";
"replace" -> "nth";
"string?" -> "fn";
"map-indexed" -> "rest";
"destructure" -> "reduce1";
"assert-same-protocol" -> "bound?";
"->>" -> "concat";
"maybe-min-hash" -> "dec";
"into" -> "defn";
"spit" -> "with-open";
"load" -> "=";
"group-by" -> "get";
"generate-class" -> "keys";
"sequence" -> "seq?";
"proxy-name" -> "hash";
"pr-on" -> "defn";
"cond->>" -> "gensym";
"isa?" -> "vector?";
"with-redefs" -> "map";
"add-watch" -> "fn";
"distinct?" -> "conj";
"select-keys" -> "with-meta";
"mk-am" -> "alength";
"with-open" -> "symbol?";
"str" -> "first";
"find-protocol-impl" -> "instance?";
"update-in" -> "assoc";
"gen-class" -> "when";
"reductions" -> "defn";
"ns" -> "name";
"merge-hash-collisions" -> "ffirst";
"assert-args" -> "meta";
"emit-hinted-impl" -> "vector";
"aset-int" -> "int";
"condp" -> "count";
"to-array-2d" -> "aset";
"mod" -> "num";
"resultset-seq" -> "defn";
"chunked-seq?" -> "instance?";
"underive" -> "apply";
"doseq" -> "cond";
"emit-defrecord" -> "when";
"ns-publics" -> "let";
"emit-defrecord" -> "remove";
"dissoc!" -> "first";
"defonce" -> "list";
"not-any?" -> "comp";
"with-out-str" -> "concat";
"extenders" -> "defn";
"->Vec" -> "let";
"doall" -> "defn";
"accessor" -> "key";
"fits-table?" -> "defn-";
"with-out-str" -> "vector";
"aset" -> "defn";
"butlast" -> "conj";
"zipmap" -> "loop";
"instance?" -> "fn";
"get-in" -> "loop";
"->ArrayChunk" -> "-";
"nary-inline" -> "defn";
"->Vec" -> "dotimes";
"with-bindings" -> "defmacro";
"ref-history-count" -> "ref";
"comp" -> "first";
"escape-class-name" -> "replace";
"definline" -> "name";
"emit-defrecord" -> "not-empty";
"map-indexed" -> "int";
"with-local-vars" -> "defmacro";
"find-protocol-impl" -> "nil?";
"parse-opts+specs" -> "var?";
"is-runtime-annotation?" -> "and";
"keep-indexed" -> "chunk-cons";
"chars" -> "seq";
"nthrest" -> "defn";
"generate-proxy" -> "replicate";
"fn" -> "symbol?";
"imap-cons" -> "rest";
"load" -> "printf";
"merge-hash-collisions" -> "hash";
"keep" -> "chunk-buffer";
"generate-class" -> "fn";
"when-let" -> "=";
"zipmap" -> "next";
"prn" -> "newline";
"if-let" -> "apply";
"get-in" -> "next";
"pmap" -> "apply";
"emit-defrecord" -> "list";
"doseq" -> "let";
"load-lib" -> "val";
"take-while" -> "rest";
"emit-hinted-impl" -> "assoc";
"lazy-seq" -> "list";
"newline" -> "*out*";
"assert-same-protocol" -> "and";
"interleave" -> "identity";
"defrecord" -> "vec";
"asm-type" -> "some";
"ns" -> "not-any?";
"memfn" -> "seq";
"reduce1" -> "defn";
"build-positional-factory" -> "seq";
"list?" -> "defn";
"partial" -> "apply";
"*'" -> "cast";
"name" -> "defn";
"filter-methods" -> "seq";
"defrecord" -> "concat";
"defrecord" -> "vector";
"swap!" -> "atom";
"isa?" -> "class?";
"condp" -> "str";
"pmap" -> "rest";
"group-by-sig" -> "pop";
"type" -> "meta";
"meta" -> "instance?";
"fnil" -> "apply";
"defprotocol" -> "emit-protocol";
"defn" -> "cons";
"max-switch-table-size" -> "bit-shift-left";
"import" -> "seq?";
"parse-opts+specs" -> "seq";
"array-map" -> "to-array";
"rand" -> "*";
"bound-fn" -> "fn";
"prep-hashes" -> "defn-";
"validate-generate-class-options" -> "first";
"load-data-reader-file" -> "assoc";
"for" -> "let";
"when-let" -> "defmacro";
"load-all" -> "binding";
"satisfies?" -> "find-protocol-impl";
"find-protocol-impl" -> "pref";
"interpose" -> "drop";
"generate-proxy" -> "concat";
"reductions" -> "when-let";
"generate-proxy" -> "vector";
"super-chain" -> "when";
"emit-defrecord" -> "dissoc";
"print-method" -> "defmulti";
"when-first" -> "seq";
"io!" -> "list";
"as->" -> "interleave";
"create-ns" -> "defn";
"clojure-version" -> "when";
"defn-" -> "name";
"concat" -> "chunk-cons";
"mk-am" -> "list";
"emit-defrecord" -> "not";
"resultset-seq" -> "comp";
"load-all" -> "sorted-set";
"assert-args" -> "list*";
"dotimes" -> "loop";
"group-by" -> "persistent!";
"merge-hash-collisions" -> "condp";
"empty?" -> "defn";
"remove-watch" -> "key";
"test" -> "defn";
"sort-by" -> "compare";
"pmap" -> "drop";
"coll?" -> "instance?";
"-cache-protocol-fn" -> "defn";
"underive" -> "disj";
"as->" -> "defmacro";
"->VecSeq" -> "deftype";
"condp" -> "=";
"reductions" -> "cons";
"doubles" -> "definline";
"partition" -> "lazy-seq";
"re-seq" -> "defn";
"some->>" -> "gensym";
"generate-proxy" -> "conj";
"some->" -> "concat";
"keep" -> "nil?";
"class" -> "defn";
"some->" -> "vector";
"add-doc-and-meta" -> "alter-meta!";
"ns" -> "map?";
"key" -> "defn";
"resultset-seq" -> "cons";
"var-get" -> "get";
"proxy-name" -> "interleave";
"shift-mask" -> "bit-shift-right";
"unchecked-dec-int" -> "defn";
"defn" -> "first";
"ancestors" -> "into1";
"file-seq" -> "tree-seq";
"or" -> "defmacro";
"juxt" -> "list*";
"flatten" -> "sequential?";
"rsubseq" -> "seq";
"gen-interface" -> "deref";
"non-private-methods" -> "not";
"dotimes" -> "unchecked-inc";
"emit-method-builder" -> "hash-map";
"alter-meta!" -> "defn";
"var?" -> "defn";
"deftype" -> "apply";
"vector-of" -> "EMPTY-NODE";
"generate-interface" -> "count";
"emit-protocol" -> "some";
"mk-bound-fn" -> "key";
"generate-class" -> "protected-final-methods";
"proxy" -> "when";
"merge-hash-collisions" -> "count";
"generate-proxy" -> "assoc";
"merge" -> "some";
"defmulti" -> "when";
"keep-indexed" -> "chunk-append";
"fits-table?" -> "seq";
"cond->>" -> "fn";
"condp" -> "defmacro";
"generate-class" -> "distinct";
"emit-protocol" -> "string?";
"alias" -> "the-ns";
"emit-hinted-impl" -> "vector?";
"fn" -> "next";
"comp" -> "identity";
"generate-class" -> "zipmap";
"filter" -> "defn";
"sorted-map-by" -> "defn";
"emit-protocol" -> "second";
"mk-bound-fn" -> "test";
"ns-resolve" -> "contains?";
"require" -> "apply";
"root-resource" -> "..";
"load-libs" -> "defn-";
"doto" -> "seq";
"generate-class" -> "let";
"emit-defrecord" -> "meta";
"filter-key" -> "amap";
"isa?" -> "inc";
"proxy-name" -> "str";
"add-doc-and-meta" -> "seq";
"to-array-2d" -> "defn";
"sorted-set" -> "keys";
"generate-class" -> "dotimes";
"spit" -> "writer";
"into" -> "reduce";
"ns-refers" -> "ns";
"zipmap" -> "vals";
"replace" -> "range";
"map" -> "seq";
"assert" -> "seq";
"unchecked-multiply-int" -> "defn";
"cond" -> "next";
"promise" -> "deref";
"range" -> "pos?";
"await-for" -> "doseq";
"load-reader" -> "load";
"generate-interface" -> "nth";
"memfn" -> "name";
"intern" -> "defn";
"-cache-protocol-fn" -> "expand-method-impl-cache";
"build-positional-factory" -> "name";
"case" -> "<=";
"destructure" -> "defn";
"binding" -> "second";
"cond->" -> "gensym";
"emit-hinted-impl" -> "map";
"proxy-super" -> "seq";
"ref-set" -> "ref";
"time" -> "let";
"await" -> "*agent*";
"filter" -> "chunk-rest";
"root-directory" -> "defn-";
"rsubseq" -> "key";
"destructure" -> "map?";
"aset" -> "set";
"defmulti" -> "hash-map";
"ex-data" -> "instance?";
"read" -> "boolean";
"parse-opts+specs" -> "name";
"map-indexed" -> "lazy-seq";
"memoize" -> "if-let";
"ref-min-history" -> "defn";
"construct-proxy" -> "defn";
"import" -> "concat";
"delay" -> "hash-map";
"bean" -> "pmap";
"rsubseq" -> "test";
"resultset-seq" -> "range";
"re-find" -> "defn";
"with-local-vars" -> "even?";
"ffirst" -> "first";
"proxy-super" -> "name";
"generate-interface" -> "str";
"select-keys" -> "conj";
"ns-imports" -> "partial";
"range" -> "and";
"->Vec" -> "loop";
"overload-name" -> "apply";
"load-data-readers" -> "*data-readers*";
"binding" -> "pop-thread-bindings";
"every?" -> "nil?";
"defn-" -> "defn";
"second" -> "next";
"prep-hashes" -> "merge-hash-collisions";
"definterface" -> "list";
"filter-key" -> "first";
"defmethod" -> "with-meta";
"extend" -> "when-not";
"shuffle" -> "defn";
"emit-protocol" -> "fn";
"filter" -> "count";
"*loading-verbosely*" -> "defonce";
"printf" -> "apply";
"ns-name" -> "defn";
"load-libs" -> "filter";
"throw-if" -> "apply";
"bean" -> "contains?";
"unchecked-subtract" -> "defn";
"validate-generate-class-options" -> "methods";
"with-redefs" -> "seq";
"refer" -> "hash-map";
"vector-of" -> "let";
"assert-args" -> "second";
"find-protocol-impl" -> "let";
"some" -> "next";
"case" -> "partition";
"loop" -> "vec";
"derive" -> "when-not";
"bound-fn*" -> "defn";
"emit-method-builder" -> "list";
"partition" -> "take";
"import" -> "conj";
"bases" -> "seq";
"assert-same-protocol" -> "println";
"with-precision" -> "first";
"partition" -> "when";
"->Vec" -> "next";
"loop" -> "concat";
"normalize-slurp-opts" -> "string?";
"extend-type" -> "defmacro";
"load" -> "*loading-verbosely*";
"loop" -> "vector";
"with-precision" -> "=";
"definline" -> "defn";
"sigs" -> "seq";
"doseq" -> "loop";
"bean" -> "and";
"filter" -> "when-let";
"binding" -> "fn";
"re-groups" -> "inc";
"cond->>" -> "repeat";
"merge-hash-collisions" -> "<";
"asm-type" -> "let";
"case" -> "contains?";
"reductions" -> "first";
"load-lib" -> "doseq";
"map-indexed" -> "chunk-first";
"prn" -> "*flush-on-newline*";
"merge-with" -> "val";
"defrecord" -> "map";
"with-out-str" -> "*out*";
"add-annotations" -> "when-let";
"every-pred" -> "defn";
"cond->>" -> "let";
"maybe-min-hash" -> "max-mask-bits";
"emit-defrecord" -> "list*";
"proxy-mappings" -> "proxy";
"doseq" -> "next";
"assoc" -> "key";
"re-matches" -> "re-groups";
"lazy-seq" -> "list*";
"frequencies" -> "transient";
"take-while" -> "lazy-seq";
"trampoline" -> "fn?";
"check-cyclic-dependency" -> "interpose";
"refer" -> "when";
"sigs" -> "assert-valid-fdecl";
"doubles" -> "seq";
"future-cancel" -> "defn";
"inc" -> "defn";
"case" -> "and";
"for" -> "loop";
"generate-proxy" -> "map";
"reify" -> "list";
"load-one" -> "conj";
"find-var" -> "defn";
"with-precision" -> "defmacro";
"add-doc-and-meta" -> "name";
"conj!" -> "defn";
"generate-interface" -> "->";
"meta" -> "fn";
"proxy" -> "list";
"load-libs" -> "seq";
"defmulti" -> "list";
"proxy" -> "get-super-and-interfaces";
"destructure" -> "nth";
"add-annotation" -> "resolve";
"seque" -> "seq";
"some->>" -> "nil?";
"pmap" -> "lazy-seq";
"ref" -> "defn";
"special-symbol?" -> "defn";
"delay" -> "list";
"+'" -> "reduce1";
"bit-not" -> "defn";
"await-for" -> "fn";
"await" -> "io!";
"set?" -> "instance?";
"range" -> "chunk";
"keep-indexed" -> "inc";
"println" -> "binding";
"disj!" -> "let";
"for" -> "unchecked-inc";
"mapcat" -> "defn";
"case" -> "apply";
"some->" -> "map";
"emit-deftype*" -> "*ns*";
"keep" -> "let";
"promise" -> "zero?";
"proxy-call-with-super" -> "assoc";
"unchecked-int" -> "defn";
"dorun" -> "next";
"interleave" -> "and";
"pmap" -> "when";
"restart-agent" -> "defn";
"slurp" -> "defn";
"keep" -> "dotimes";
"emit-protocol" -> "repeat";
"await-for" -> "let";
"unchecked-double" -> "defn";
"check-cyclic-dependency" -> "apply";
"load-data-reader-file" -> "*file*";
"get-in" -> "identical?";
"drop-while" -> "fn";
"and" -> "list";
"load-data-reader-file" -> "defn-";
"destructure" -> "str";
"reduce1" -> "first";
"definterface" -> "meta";
"supers" -> "disj";
"chunk-append" -> "defn";
"re-seq" -> "cons";
"descendants" -> "class?";
"emit-impl" -> "keyword";
"with-in-str" -> "concat";
"emit-protocol" -> "let";
"ns-refers" -> "filter-key";
"/" -> "reduce1";
"->VecSeq" -> "and";
"generate-interface" -> "first";
"with-in-str" -> "vector";
"mk-am" -> "gensym";
"subseq" -> "let";
"iterate" -> "defn";
"prn-str" -> "defn";
"definline" -> "comp";
"check-cyclic-dependency" -> "rest";
"future" -> "seq";
"unchecked-short" -> "defn";
"filter-methods" -> "or";
"defstruct" -> "concat";
"merge-hash-collisions" -> "first";
"ns" -> "str";
"-cache-protocol-fn" -> "str";
"cond->" -> "fn";
"emit-protocol" -> "*ns*";
"agent" -> "let";
"fn" -> "with-meta";
"proxy-name" -> "subs";
"supers" -> "into1";
"reset!" -> "atom";
"aset-float" -> "def-aset";
"into1" -> "instance?";
"merge-hash-collisions" -> "=";
"load-lib" -> "cond";
"print-object" -> "str";
"await" -> "when";
"underive" -> "dissoc";
"defrecord" -> "parse-opts+specs";
"every?" -> "cond";
"rand-int" -> "defn";
"lazy-cat" -> "concat";
"memoize" -> "apply";
"loop" -> "conj";
"concat" -> "seq";
"class?" -> "defn";
"binding" -> "let";
"frequencies" -> "defn";
"validate-fields" -> "some";
"refer" -> "not";
"libspec?" -> "vector?";
"memoize" -> "swap!";
"assoc" -> "nnext";
"emit-defrecord" -> "empty";
"maybe-destructured" -> "list";
"some->>" -> "fn";
"doseq" -> "unchecked-inc";
"filter" -> "cons";
"floats" -> "definline";
"partition" -> "list";
"select-keys" -> "map";
"throw-if" -> "drop";
"locking" -> "list";
"defrecord" -> "build-positional-factory";
"xml-seq" -> "seq";
"maybe-destructured" -> "every?";
"vals" -> "map";
"bean" -> "proxy";
"generate-class" -> "next";
"delay?" -> "instance?";
"ancestors" -> "not-empty";
"gen-interface" -> "*compile-files*";
"assert-valid-fdecl" -> "str";
"accessor" -> "defn";
"emit-defrecord" -> "gensym";
"case-map" -> "into1";
"reify" -> "meta";
"isa?" -> "global-hierarchy";
"def-aset" -> "seq";
"take-while" -> "when";
"double-array" -> "defn";
"emit-hinted-impl" -> "defn-";
"emit-deftype*" -> "let";
"build-positional-factory" -> "defn";
"==" -> "next";
"underive" -> "not-empty";
"import" -> "map";
"underive" -> "flatten";
"emit-protocol" -> "gen-interface";
"find-keyword" -> "keyword?";
"bean" -> "rest";
"gen-class" -> "generate-class";
"keep-indexed" -> "seq";
"destructure" -> "->";
"get-thread-bindings" -> "defn";
"assoc-in" -> "defn";
"bean" -> "keyword";
"defmulti" -> "meta";
"declare" -> "list";
"defmethod" -> "concat";
"parse-opts+specs" -> "when-let";
"bound?" -> "every?";
"->>" -> "seq";
"+'" -> "defn";
"juxt" -> "fn";
"def-aset" -> "name";
"parents" -> "get";
"map" -> "defn";
"generate-class" -> "vals";
"merge-with" -> "some";
"apply" -> "list*";
"mk-bound-fn" -> "defn";
"dotimes" -> "concat";
"load-lib" -> "*ns*";
"float" -> "defn";
"fn" -> "seq?";
"delay" -> "list*";
"unchecked-long" -> "defn";
"assert-valid-fdecl" -> "first";
"filter" -> "first";
"vector-of" -> "loop";
"dotimes" -> "vector";
"when-first" -> "when-let";
"assert-args" -> "*ns*";
"ctor-sigs" -> "apply";
"butlast" -> "seq";
"list*" -> "spread";
"int-array" -> "defn";
"derive" -> "conj";
"let" -> "concat";
"keyword" -> "keyword?";
"ns" -> "defmacro";
"setup-reference" -> "defn";
"io!" -> "string?";
"create-struct" -> "defn";
"to-array-2d" -> "first";
"loop" -> "map";
"amap" -> "apply";
"extends?" -> "or";
"ns-refers" -> "defn";
"flatten" -> "complement";
"comment" -> "defmacro";
"aset" -> "array";
"floats" -> "seq";
"chunk-cons" -> "defn";
"drop-while" -> "let";
"partition-all" -> "lazy-seq";
"split-at" -> "defn";
"vector-of" -> "next";
"interleave" -> "apply";
"ns-imports" -> "ns-map";
"alter" -> "ref";
"condp" -> "if-let";
"map" -> "chunk-rest";
"destructure" -> "first";
"future?" -> "defn";
"bigint" -> "instance?";
"derive" -> "assoc";
"cond->" -> "repeat";
"assert-same-protocol" -> "when";
"*loaded-libs*" -> "defonce";
"data-reader-urls" -> "enumeration-seq";
"->Vec" -> "+";
"if-let" -> "list";
"emit-defrecord" -> "hash-set";
"remove" -> "complement";
"destructure" -> "=";
"emit-extend-protocol" -> "concat";
"sync" -> "concat";
"build-positional-factory" -> "count";
"sync" -> "vector";
"rsubseq" -> "defn";
"emit-impl" -> "drop";
"print-sequential" -> "*print-level*";
"doseq" -> "with-meta";
"if-let" -> "assert-args";
"cond->" -> "let";
"with-loading-context" -> "seq";
"pmap" -> "every?";
"emit-defrecord" -> "some";
"->Vec" -> "into-array";
"dissoc" -> "let";
"interleave" -> "rest";
"ns" -> "first";
".." -> "seq";
"ref-history-count" -> "defn";
"implements?" -> "and";
"some->>" -> "repeat";
"print-str" -> "defn";
"replace" -> "if-let";
"remove-watch" -> "defn";
"pr-str" -> "apply";
"prep-ints" -> "let";
"sort" -> "let";
"ns" -> "=";
"the-class" -> "some";
"generate-proxy" -> "defn-";
"ns-map" -> "the-ns";
"refer-clojure" -> "seq";
"protocol?" -> "boolean";
"parse-opts+specs" -> "set";
"extends?" -> "defn";
"data-reader-var" -> "symbol";
"emit-defrecord" -> "letfn";
"when-first" -> "count";
"emit-defrecord" -> "keys";
"pvalues" -> "defmacro";
"deftype" -> "validate-fields";
"prep-hashes" -> "or";
"underive" -> "alter-var-root";
"emit-protocol" -> "-reset-methods";
"with-open" -> "concat";
"some->>" -> "let";
"counted?" -> "defn";
"loop" -> "vector?";
"bigdec" -> "instance?";
"expand-method-impl-cache" -> "if-let";
"dosync" -> "concat";
"generate-class" -> "symbol";
"when-not" -> "test";
"with-redefs" -> "with-redefs-fn";
"while" -> "apply";
"prep-hashes" -> "hash";
"bytes" -> "list";
"load-lib" -> "let";
"assert-args" -> "let";
"build-positional-factory" -> "nth";
"ifn?" -> "instance?";
"prep-hashes" -> "count";
"time" -> "prn";
"build-positional-factory" -> "->";
"supers" -> "not-empty";
"into-array" -> "seq";
"libspec?" -> "defn-";
"neg?" -> "defn";
"->Vec" -> "identical?";
"float-array" -> "defn";
"print-method" -> "meta";
"binding-conveyor-fn" -> "defn";
"mapv" -> "map";
"read-string" -> "defn";
"boolean" -> "defn";
"->ArrayChunk" -> "inc";
"generate-proxy" -> "seq";
"generate-class" -> "into-array";
"check-cyclic-dependency" -> "*pending-paths*";
"expand-method-impl-cache" -> "shift-mask";
"bean" -> "lazy-seq";
"defstruct" -> "create-struct";
"derive" -> "print-str";
"extends?" -> "implements?";
"defn-" -> "defmacro";
"->Vec" -> "zero?";
"emit-protocol" -> "munge";
"parse-opts+specs" -> "->";
"juxt" -> "let";
"seque" -> "defn";
"disj!" -> "next";
"emit-protocol" -> "loop";
"parse-opts+specs" -> "cons";
"->Vec" -> "bit-and";
"make-array" -> "let";
"build-positional-factory" -> "str";
"pr-str" -> "pr";
"the-class" -> "cond";
"unchecked-remainder-int" -> "defn";
"fn" -> "concat";
"ref-set" -> "defn";
"comp" -> "apply";
"sequence" -> "seq";
"isa?" -> "or";
"emit-hinted-impl" -> "name";
"unchecked-add" -> "defn";
"-" -> "reduce1";
"deftype" -> "list";
"make-array" -> "dotimes";
"fn" -> "vector";
"areduce" -> "let";
"with-out-str" -> "seq";
"/" -> "defn";
"when-let" -> "apply";
"map-indexed" -> "chunked-seq?";
"emit-defrecord" -> "fn";
"alias" -> "*ns*";
"pr-on" -> "print-method";
"print-sequential" -> "loop";
"slurp" -> "str";
"load-one" -> "defn-";
"rsubseq" -> "when-let";
"emit-protocol" -> "next";
"memoize" -> "atom";
"lazy-cat" -> "map";
"partition-all" -> "take";
"definline" -> "defmacro";
"iterate" -> "cons";
"*" -> "reduce1";
"frequencies" -> "reduce";
"binding" -> "loop";
"subseq" -> "next";
"validate-fields" -> "let";
"bases" -> "defn";
"distinct" -> "conj";
"emit-method-builder" -> "gensym";
"->Vec" -> "-";
"deref" -> "ref";
"aset-double" -> "double";
"map" -> "count";
"aset-float" -> "float";
"trampoline" -> "let";
"await" -> "agent";
"with-bindings*" -> "defn";
"defmulti" -> "instance?";
"load-all" -> "dosync";
"find-keyword" -> "string?";
"expand-method-impl-cache" -> "partition";
"bit-and" -> "reduce1";
"generate-interface" -> "methods";
"sigs" -> "map?";
"tree-seq" -> "lazy-seq";
"assoc!" -> "key";
"binding" -> "next";
"with-bindings" -> "apply";
"derive" -> "assert";
"range" -> "lazy-seq";
"throw-if" -> "when";
"underive" -> "val";
"merge-with" -> "fn";
"->Vec" -> "rseq";
"future-call" -> "defn";
"isa?" -> "defn";
"with-local-vars" -> "apply";
"send" -> "apply";
"zipmap" -> "assoc";
"load-data-readers" -> "load-data-reader-file";
"print-meta" -> "defn-";
"add-annotation" -> "descriptor";
"defrecord" -> "seq";
"map" -> "when-let";
"reductions" -> "if-let";
"generate-class" -> "+";
"tree-seq" -> "when";
"refer" -> "instance?";
"not-every?" -> "every?";
"cycle" -> "lazy-seq";
"throw-if" -> "drop-while";
"assert-same-protocol" -> "meta";
"memfn" -> "defmacro";
"merge-with" -> "let";
"generate-class" -> "when-not";
"vec" -> "defn";
"range" -> "when";
"select-keys" -> "seq";
"pvalues" -> "pcalls";
"maybe-destructured" -> "gensym";
"io!" -> "let";
"map-indexed" -> "chunk-buffer";
"nfirst" -> "fn";
"amap" -> "aclone";
"expand-method-impl-cache" -> "maybe-min-hash";
"ref-set" -> "set";
"disj" -> "let";
"xml-seq" -> "defn";
"condp" -> "apply";
"defrecord" -> "name";
"find-keyword" -> "cond";
"mk-am" -> "let";
"remove-ns" -> "defn";
"ratio?" -> "defn";
"def-aset" -> "defn";
"load-all" -> "commute";
"distinct?" -> "defn";
"aset-byte" -> "def-aset";
"map" -> "cons";
"defmulti" -> "string?";
"defonce" -> "let";
"every?" -> "next";
"agent-errors" -> "list";
"zipmap" -> "map";
"derive" -> "class?";
"get-super-and-interfaces" -> "next";
"parse-impls" -> "loop";
"keep-indexed" -> "defn";
"emit-deftype*" -> "symbol";
"import" -> "seq";
"concat" -> "chunk-rest";
"if-not" -> "concat";
"generate-proxy" -> "reduce1";
"bigint" -> "cond";
"when-first" -> "defmacro";
"drop" -> "fn";
"bean" -> "when";
"assert" -> "str";
"some->" -> "seq";
"time" -> "-";
"not-every?" -> "not";
"with-open" -> "vector?";
"assert-same-protocol" -> "binding";
"fits-table?" -> "<";
"nthrest" -> "pos?";
"replicate" -> "defn";
"+" -> "reduce1";
"descendants" -> "global-hierarchy";
"into" -> "persistent!";
"isa?" -> "count";
"emit-extend-protocol" -> "map";
"gen-class" -> "let";
"doseq" -> "concat";
"print-method" -> "keyword?";
"parse-impls" -> "next";
"add-annotations" -> "is-runtime-annotation?";
"generate-class" -> "..";
"print-simple" -> "print-meta";
"doseq" -> "vector";
"ints" -> "list";
"filter-methods" -> "first";
"merge-hash-collisions" -> "fnil";
"fn" -> "sigs";
"emit-defrecord" -> "bit-xor";
"root-resource" -> "defn-";
"emit-defrecord" -> "let";
"deftype" -> "emit-deftype*";
"newline" -> "defn";
"build-positional-factory" -> "=";
"keep-indexed" -> "chunk-rest";
"->VecNode" -> "deftype";
"as->" -> "apply";
"emit-protocol" -> "symbol";
"dotimes" -> "vector?";
"assert" -> "pr-str";
"bean" -> "alength";
"re-groups" -> "defn";
"rationalize" -> "num";
"the-class" -> "let";
"non-private-methods" -> "fn";
"add-annotation" -> "eval";
"extend" -> "assoc-in";
"emit-protocol" -> "vals";
"let" -> "vector?";
"load" -> "*pending-paths*";
"emit-defrecord" -> "*ns*";
"filterv" -> "conj!";
"bigdec" -> "cond";
"check-cyclic-dependency" -> "when";
"letfn" -> "vec";
"maybe-min-hash" -> "for";
"assoc!" -> "nnext";
"when-first" -> "first";
"proxy" -> "if-not";
"or" -> "apply";
"dissoc" -> "next";
"interleave" -> "lazy-seq";
"for" -> "concat";
"for" -> "vector";
"vector" -> "defn";
"update-in" -> "defn";
"concat" -> "defn";
"when-first" -> "=";
"symbol" -> "ns";
"letfn" -> "concat";
"build-positional-factory" -> "range";
"keyword" -> "string?";
"time" -> "vector";
"drop-last" -> "drop";
"print" -> "defn";
"doto" -> "defmacro";
"proxy-name" -> "apply";
"identical?" -> "defn";
"bound-fn" -> "concat";
"with-local-vars" -> "take-nth";
"resultset-seq" -> "keyword";
"imap-cons" -> "instance?";
"->Vec" -> "boolean";
"emit-deftype*" -> "with-meta";
"xml-seq" -> "comp";
"definterface" -> "fn";
"add-doc-and-meta" -> "defmacro";
"bigint" -> "long";
"interleave" -> "when";
"most-specific" -> "when";
"load-libs" -> "interleave";
"generate-class" -> "replicate";
"case-map" -> "sorted-map";
"case" -> "list";
"send-via" -> "binding-conveyor-fn";
"assert" -> "defmacro";
"for" -> "conj";
"keep-indexed" -> "when-let";
"bean" -> "dissoc";
"cond->>" -> "->>";
"case" -> "every?";
"rseq" -> "defn";
"send-off" -> "defn";
"emit-method-builder" -> "fn";
"mod" -> "let";
"merge-hash-collisions" -> "and";
"reversible?" -> "defn";
"add-annotations" -> "resolve";
"->VecSeq" -> "when";
"proxy-super" -> "defmacro";
"amap" -> "alength";
"fn" -> "assert";
"fn" -> "map";
"destructure" -> "get";
"areduce" -> "loop";
"load-lib" -> "symbol";
"defmacro" -> "list";
"aset-long" -> "long";
"keyword" -> "cond";
"*loaded-libs*" -> "sorted-set";
"expand-method-impl-cache" -> "int";
"seque" -> "cons";
"maybe-min-hash" -> "fn";
"symbol" -> "name";
"spread" -> "seq";
"with-precision" -> "apply";
"mapv" -> "conj!";
"memoize" -> "find";
"ns-interns" -> "ns";
"case" -> "prep-ints";
"load" -> "when";
"protected-final-methods" -> "filter-methods";
"-" -> "defn";
"import" -> "name";
"emit-protocol" -> "with-meta";
"doto" -> "first";
"load-lib" -> "select-keys";
"load-libs" -> "str";
"shorts" -> "concat";
"drop" -> "let";
"import" -> "reduce1";
"bigdec" -> "long";
"defmulti" -> "check-valid-options";
"refer" -> "keys";
"loop" -> "destructure";
"sorted-map-by" -> "comparator";
"loop" -> "seq";
"commute" -> "ref";
"while" -> "when";
"check-valid-options" -> "map";
"*" -> "defn";
"longs" -> "concat";
"generate-class" -> "concat";
"rest" -> "fn";
"fits-table?" -> "max-switch-table-size";
"map" -> "first";
"generate-proxy" -> "proxy-name";
"find-protocol-impl" -> "butlast";
"valid-java-method-name" -> "defn-";
"load-lib" -> "deref";
"nthrest" -> "and";
"resultset-seq" -> "apply";
"bases" -> "cons";
"load-lib" -> "load-one";
"print-sequential" -> "sequence";
"->Vec" -> "assoc";
"proxy" -> "fn";
"bit-and" -> "defn";
"compile" -> "binding";
"max-switch-table-size" -> "max-mask-bits";
"load-data-reader-file" -> "map?";
"destructure" -> "pmap";
"zero?" -> "defn";
"bit-flip" -> "defn";
"reductions" -> "rest";
"keep-indexed" -> "count";
"refer" -> "doseq";
"fn" -> "vector?";
"agent-error" -> "defn";
"non-private-methods" -> "let";
"vary-meta" -> "defn";
"time" -> "concat";
"map-indexed" -> "letfn";
"protocol?" -> "defn-";
"group-by-sig" -> "fn";
"assoc" -> "first";
"destructure" -> "contains?";
"fnil" -> "nil?";
"proxy" -> "let";
"with-local-vars" -> "hash-map";
"load" -> "flush";
"while" -> "list";
"defmulti" -> "let";
"sort-by" -> "sort";
"when-let" -> "when";
"vector" -> "cons";
"root-resource" -> "name";
"doseq" -> "vector?";
"concat" -> "cons";
"parse-opts+specs" -> "methods";
"sequence" -> "or";
"group-by-sig" -> "let";
"reduced?" -> "defn";
"proxy" -> "*ns*";
"pr-on" -> "*print-dup*";
"mod" -> "rem";
"load-all" -> "deref";
"ref-max-history" -> "ref";
"defrecord" -> "defn";
"load-all" -> "load-one";
"generate-class" -> "assoc";
"definterface" -> "let";
"prep-hashes" -> "identity";
"io!" -> "next";
"disj" -> "next";
"print-meta" -> "pr-on";
"nthrest" -> "rest";
"conj" -> "first";
"->" -> "list";
"->Vec" -> "doto";
"println-str" -> "with-out-str";
"unchecked-negate" -> "defn";
"assert-same-protocol" -> "not=";
"integer?" -> "defn";
"sigs" -> "first";
"into-array" -> "defn";
"some-fn" -> "defn";
"refer" -> "ns-publics";
"amap" -> "list";
"protected-final-methods" -> "defn-";
"emit-method-builder" -> "let";
"definterface" -> "*ns*";
"proxy" -> "init-proxy";
"for" -> "vector?";
"keep-indexed" -> "cons";
"descendants" -> "defn";
"take-last" -> "loop";
"ns-resolve" -> "the-ns";
"emit-extend-type" -> "partial";
"is-runtime-annotation?" -> "is-annotation?";
"assoc!" -> "defn";
"ns" -> "and";
"keep" -> "when-not";
"filter-methods" -> "method-sig";
"time" -> "/";
"for" -> "chunk-cons";
"validate-generate-class-options" -> "when";
"ns" -> "refer";
"+" -> "defn";
"fits-table?" -> "max";
"emit-extend-protocol" -> "defn-";
"number?" -> "defn";
"merge-hash-collisions" -> "apply";
"isa?" -> "=";
"partition-by" -> "seq";
"parents" -> "into1";
"interleave" -> "every?";
"areduce" -> "unchecked-inc";
"make-hierarchy" -> "defn";
"print-sequential" -> "zero?";
"with-in-str" -> "seq";
"ns" -> "in-ns";
"load-data-reader-file" -> "ex-info";
"most-specific" -> "every?";
"with-redefs" -> "defmacro";
"find-keyword" -> "symbol?";
"sequence" -> "defn";
"read" -> "defn";
"cond->>" -> "concat";
"defstruct" -> "seq";
"if-let" -> "nil?";
"fits-table?" -> "ints";
"cond->>" -> "vector";
"ctor-sigs" -> "not";
"destructure" -> "partition";
"await" -> "doseq";
"take-last" -> "next";
"prn" -> "defn";
"integer?" -> "or";
"some-fn" -> "or";
"loop" -> "reduce1";
"keys" -> "map";
"generate-proxy" -> "or";
"booleans" -> "concat";
"letfn" -> "map";
"lazy-cat" -> "seq";
"filter" -> "chunk";
"expand-method-impl-cache" -> "into1";
"map" -> "identity";
"reify" -> "let";
"resultset-seq" -> "struct";
"definterface" -> "gen-interface";
"alter" -> "defn";
"aset" -> "apply";
"generate-class" -> "conj";
"quot" -> "num";
"emit-deftype*" -> "concat";
"await" -> "fn";
"with-local-vars" -> "list";
"emit-defrecord" -> "symbol";
"generate-proxy" -> "count";
"print-meta" -> "or";
"every-pred" -> "and";
"print-map" -> "print-sequential";
"emit-defrecord" -> "vals";
"with-local-vars" -> "assert-args";
"reductions" -> "lazy-seq";
"ns-interns" -> "filter-key";
"deref" -> "defn";
"rand" -> "defn";
"frequencies" -> "get";
"special-symbol?" -> "contains?";
"load-data-reader-file" -> "str";
"ancestors" -> "let";
"parse-impls" -> "seq?";
"libspec?" -> "or";
"with-open" -> "seq";
"xml-seq" -> "tree-seq";
"nthnext" -> "loop";
"re-matcher" -> "defn";
"mk-bound-fn" -> "compare";
"resultset-seq" -> "lazy-seq";
"dosync" -> "seq";
"filterv" -> "transient";
"comparator" -> "cond";
"prep-hashes" -> "case-map";
"emit-protocol" -> "vec";
"proxy-name" -> "into1";
"underive" -> "let";
"printf" -> "format";
"+'" -> "cast";
"defmethod" -> "seq";
"refer" -> "let";
"def-aset" -> "defmacro";
"interpose" -> "repeat";
"and" -> "let";
"slurp" -> "char";
"biginteger" -> "instance?";
"throw-if" -> "format";
"select-keys" -> "defn";
"emit-protocol" -> "concat";
"emit-protocol" -> "vector";
"derive" -> "reduce1";
"memoize" -> "val";
"load" -> "binding";
"dotimes" -> "seq";
"nthnext" -> "next";
"vals" -> "defn";
"assert-args" -> "when-not";
"aset" -> "aget";
"load-libs" -> "throw-if";
"->" -> "meta";
"nfirst" -> "next";
"assoc-in" -> "get";
"some->>" -> "->>";
"nthrest" -> "dec";
"let" -> "destructure";
"generate-proxy" -> "nth";
"refer" -> "*ns*";
"ns-unmap" -> "ns";
"derive" -> "global-hierarchy";
"expand-method-impl-cache" -> "make-array";
"when-let" -> "list";
"-'" -> "reduce1";
"filter" -> "rest";
"bean" -> "val";
"comparator" -> "fn";
"let" -> "seq";
"mk-am" -> "symbol";
"pmap" -> "fn";
"symbol" -> "defn";
"concat" -> "first";
"validate-generate-class-options" -> "remove";
"deliver" -> "defn";
"generate-class" -> "map";
"get-in" -> "seq";
"distinct" -> "seq";
"zipmap" -> "seq";
"when-let" -> "assert-args";
"for" -> "chunk-append";
"emit-hinted-impl" -> "->";
"binding" -> "concat";
"when-not" -> "cons";
"for" -> "when-first";
"unchecked-inc" -> "defn";
"throw-if" -> "not=";
"assert-same-protocol" -> "doseq";
"parse-opts+specs" -> "resolve";
"emit-hinted-impl" -> "cons";
"partial" -> "fn";
"root-directory" -> "subs";
"load-data-reader-file" -> "reduce";
"case" -> "keyword?";
"binding" -> "vector";
"sorted-set-by" -> "keys";
"pr" -> "next";
"map-indexed" -> "let";
"get-proxy-class" -> "get-super-and-interfaces";
"print-dup" -> "defmulti";
"fnil" -> "fn";
"with-bindings*" -> "push-thread-bindings";
"maybe-destructured" -> "let";
"map-indexed" -> "dotimes";
"sync" -> "seq";
"prependss" -> "symbol?";
"emit-extend-protocol" -> "seq";
"future" -> "defmacro";
"partition" -> "let";
"keyword" -> "symbol?";
"locking" -> "let";
"with-bindings" -> "list";
"keep-indexed" -> "first";
"prep-ints" -> "zero?";
"defstruct" -> "name";
"distinct?" -> "=";
"print-method" -> "fn";
"imap-cons" -> "cond";
"proxy" -> "loop";
"gen-interface" -> "generate-interface";
"munge" -> "defn";
"check-valid-options" -> "seq";
"some->>" -> "vector";
"->ArrayChunk" -> "count";
"bound-fn*" -> "apply";
"emit-protocol" -> "assoc";
"->>" -> "first";
"binding" -> "conj";
"parse-opts+specs" -> "maybe-destructured";
"emit-defrecord" -> "+";
"split-with" -> "defn";
"re-matches" -> "defn";
"ns-interns" -> "defn";
"assert-args" -> "concat";
"validate-fields" -> "when-not";
"with-out-str" -> "str";
"with-loading-context" -> "defmacro";
"proxy-call-with-super" -> "defn";
"ns-publics" -> "ns";
"extend-protocol" -> "emit-extend-protocol";
"print-map" -> "val";
"print-method" -> "let";
"butlast" -> "first";
"mk-bound-fn" -> "comparator";
"emit-hinted-impl" -> "first";
".." -> "defmacro";
"definline" -> "apply";
"ns-unalias" -> "ns";
"await" -> "let";
"root-resource" -> "replace";
"group-by" -> "fn";
"print-meta" -> "count";
"isa?" -> "supers";
"filterv" -> "defn";
"condp" -> "list";
"proxy" -> "next";
"parents" -> "not-empty";
"replace" -> "find";
"defmulti" -> "next";
"reduce" -> "val";
"apply" -> "spread";
"find-protocol-impl" -> "map";
"refer-clojure" -> "defmacro";
"deref-future" -> "defn";
"expand-method-impl-cache" -> "remove";
"emit-deftype*" -> "conj";
"mk-am" -> "with-meta";
"def-aset" -> "array";
"resolve" -> "*ns*";
"extends?" -> "get";
"frequencies" -> "persistent!";
"add-annotations" -> "descriptor";
"generate-proxy" -> "most-specific";
"imap-cons" -> "let";
"defn" -> "list";
"resultset-seq" -> "when";
"defrecord" -> "->";
"struct" -> "vals";
"->ArrayChunk" -> "nth";
"->VecSeq" -> "val";
"destructure" -> "nthnext";
"print-sequential" -> "neg?";
"->>" -> "defmacro";
"print-meta" -> "when-let";
"mapv" -> "into";
"case" -> "gensym";
"->Vec" -> "inc";
"pref" -> "defn-";
"generate-proxy" -> "->";
"generate-proxy" -> "cons";
"rational?" -> "integer?";
"thread-bound?" -> "defn";
"emit-protocol" -> "sigs";
"defrecord" -> "str";
"generate-class" -> "mapcat";
"when-not" -> "defmacro";
"underive" -> "derive";
"fn" -> "seq";
"cond->>" -> "assert";
"cond->>" -> "map";
"ref" -> "apply";
"*clojure-version*" -> "clojure-version";
"emit-protocol" -> "conj";
"if-let" -> "let";
"spread" -> "defn";
"cond->" -> "concat";
"pmap" -> "let";
"cond->" -> "vector";
"ns-imports" -> "val";
"merge" -> "conj";
"as->" -> "list";
"bit-xor" -> "reduce1";
"mapv" -> "transient";
"load-lib" -> "remove-ns";
"emit-defrecord" -> "with-meta";
"load-data-readers" -> "defn-";
"rsubseq" -> "take-while";
"get-in" -> "reduce1";
"merge-hash-collisions" -> "into1";
"is-annotation?" -> "class?";
"var-set" -> "val";
"future-done?" -> "defn";
"or" -> "list";
"some->>" -> "concat";
"maybe-destructured" -> "symbol?";
"range" -> "chunk-buffer";
"import" -> "str";
"satisfies?" -> "boolean";
"emit-protocol" -> "vector?";
"derive" -> "or";
"add-annotation" -> "instance?";
"when-first" -> "apply";
"->VecSeq" -> "empty";
"generate-class" -> "inc";
"add-watch" -> "key";
"last" -> "first";
"parse-impls" -> "assoc";
"->ArrayChunk" -> "<";
"generate-proxy" -> "first";
"maybe-destructured" -> "next";
"assert-same-protocol" -> "let";
"emit-defrecord" -> "when-not";
"generate-interface" -> "when";
"commute" -> "defn";
"generate-proxy" -> "=";
"refer" -> "ns-interns";
"assoc!" -> "first";
"prn-str" -> "apply";
"for" -> "seq";
"shorts" -> "definline";
"bigint" -> "number?";
"bean" -> "keys";
"biginteger" -> "cond";
"letfn" -> "seq";
"binding" -> "vector?";
"re-seq" -> "lazy-seq";
"longs" -> "definline";
"agent" -> "setup-reference";
"->ArrayChunk" -> "reduce";
"-reset-methods" -> "defn";
"group-by" -> "let";
"emit-protocol" -> "map";
"generate-interface" -> "make-array";
"future-call" -> "get";
"subseq" -> "mk-bound-fn";
"extend" -> "defn";
"if-not" -> "test";
"aset-char" -> "char";
"load-string" -> "let";
"proxy" -> "symbol";
"defrecord" -> "defmacro";
"some" -> "seq";
"not-any?" -> "not";
"reduce1" -> "chunk-first";
"map" -> "chunk";
"supers" -> "let";
"vector-of" -> "ams";
"check-cyclic-dependency" -> "some";
"areduce" -> "concat";
"is-annotation?" -> "defn-";
"ns" -> "gen-class";
"map" -> "and";
"with-precision" -> "list";
"emit-extend-protocol" -> "extend-type";
"derive" -> "defn";
"areduce" -> "vector";
"->Vec" -> "seq";
"pop!" -> "defn";
"data-reader-var" -> "defn-";
"defn" -> "meta";
"fnext" -> "fn";
"get-super-and-interfaces" -> "bases";
"case" -> "keys";
"loop" -> "count";
"->Vec" -> "unchecked-multiply-int";
"process-annotation" -> "defn-";
"and" -> "next";
"deftype" -> "let";
"defmacro" -> "nil?";
"-'" -> "defn";
"emit-defrecord" -> "identical?";
"definterface" -> "import";
"->VecSeq" -> "instance?";
"if-not" -> "seq";
"comp" -> "list*";
"group-by-sig" -> "vals";
"generate-class" -> "defn-";
"memfn" -> "apply";
"mod" -> "+";
"bigdec" -> "number?";
"definterface" -> "symbol";
"load-one" -> "load";
"prep-hashes" -> "shift-mask";
"some->" -> "interleave";
"build-positional-factory" -> "apply";
"defonce" -> "when-not";
"deftype" -> "*ns*";
"defmacro" -> "string?";
"filter" -> "lazy-seq";
"chunk-cons" -> "chunk";
"ns-refers" -> "and";
"reductions" -> "list";
"case-map" -> "zipmap";
"keep" -> "chunk-cons";
"mapv" -> "defn";
"mapcat" -> "apply";
"symbol?" -> "defn";
"maybe-destructured" -> "loop";
"parse-opts+specs" -> "apply";
"odd?" -> "defn";
"println" -> "prn";
"fn" -> "name";
"defmulti" -> "deref";
"add-annotation" -> "process-annotation";
"doseq" -> "seq";
"bound-fn" -> "bound-fn*";
"gen-class" -> "*compile-files*";
"some->" -> "->";
"restart-agent" -> "apply";
"slurp" -> "apply";
"with-out-str" -> "defmacro";
"rem" -> "defn";
"ns-imports" -> "instance?";
"partition-by" -> "defn";
"longs" -> "seq";
"generate-class" -> "seq";
"print-sequential" -> "*print-length*";
"->VecSeq" -> "nil?";
"repeat" -> "defn";
"setup-reference" -> "apply";
"biginteger" -> "long";
"bit-or" -> "reduce1";
"with-precision" -> "binding";
"select-keys" -> "first";
"map" -> "rest";
"to-array-2d" -> "when";
"nary-inline" -> "list";
"isa?" -> "contains?";
"generate-class" -> "add-annotations";
"add-annotations" -> "when";
"emit-impl" -> "fn";
"ns-unmap" -> "defn";
"->ArrayChunk" -> "=";
"prep-ints" -> "fits-table?";
"filterv" -> "reduce";
"reify" -> "with-meta";
"use" -> "load-libs";
"rand-int" -> "int";
"short" -> "defn";
"io!" -> "concat";
"->Vec" -> "aset";
"case" -> "fn";
"overload-name" -> "repeat";
"partition-all" -> "let";
"intern" -> "when";
"re-groups" -> "<=";
"generate-proxy" -> ">";
"true?" -> "defn";
"replace" -> "val";
"mk-am" -> "concat";
"defmulti" -> "with-meta";
"generate-class" -> "filter";
"mk-am" -> "vector";
"import" -> "first";
"gensym" -> "intern";
"await1" -> "defn";
"time" -> "seq";
"to-array-2d" -> "make-array";
"dorun" -> "seq";
"print-meta" -> "=";
"delay" -> "with-meta";
"defonce" -> "concat";
"munge" -> "str";
"str" -> "nil?";
"filterv" -> "->";
"defonce" -> "vector";
"isa?" -> "and";
"load-lib" -> "print-str";
"filter" -> "chunk-first";
"imap-cons" -> "loop";
"import" -> "=";
"false?" -> "defn";
"bound-fn" -> "seq";
"mod" -> "zero?";
"defmacro" -> "fn";
"chunk-cons" -> "rest";
"init-proxy" -> "defn";
"emit-protocol" -> "mapcat";
"add-classpath" -> "defn";
"update-in" -> "get";
"tree-seq" -> "fn";
"throw-if" -> "let";
"find" -> "map";
"for" -> "reduce1";
"definterface" -> "with-meta";
"print-str" -> "apply";
"re-seq" -> "when";
"load-libs" -> "interpose";
"ns" -> "when";
"gen-class" -> "vec";
"<=" -> "next";
"doseq" -> "nnext";
"long" -> "defn";
"all-ns" -> "defn";
"to-array-2d" -> "to-array";
"reduce1" -> "chunk-next";
"ns-refers" -> "ns-map";
"fits-table?" -> "apply";
"proxy" -> "generate-proxy";
"partition-by" -> "count";
"flush" -> "*out*";
"booleans" -> "definline";
"asm-type" -> "defn-";
"generate-class" -> "key";
"emit-method-builder" -> "with-meta";
"juxt" -> "conj";
"doto" -> "apply";
"root-resource" -> "str";
"set-agent-send-executor!" -> "defn";
"emit-defrecord" -> "vec";
"prep-hashes" -> "maybe-min-hash";
"merge-hash-collisions" -> "list";
"promise" -> "defn";
"load" -> "doseq";
"ctor-sigs" -> "for";
"cond->" -> "assert";
"cond->" -> "map";
"extend" -> "implements?";
"dissoc" -> "map";
"emit-defrecord" -> "concat";
"memoize" -> "fn";
"emit-defrecord" -> "vector";
"ref-max-history" -> "defn";
"get-validator" -> "defn";
"into" -> "meta";
"import" -> "defmacro";
"ns-publics" -> "filter-key";
"most-specific" -> "some";
"map" -> "apply";
"bean" -> "fn";
"proxy-name" -> "sorted-set";
"load-all" -> "conj";
"shorts" -> "seq";
"prep-ints" -> "map";
"complement" -> "defn";
"partition-by" -> "when-let";
"some->" -> "defmacro";
"data-reader-var" -> "intern";
"first" -> "fn";
"construct-proxy" -> "to-array";
"bit-xor" -> "defn";
"rational?" -> "ratio?";
"case" -> "cond";
"loop" -> "interleave";
"definline" -> "eval";
"some->>" -> "map";
"add-annotation" -> "doseq";
"assert-valid-fdecl" -> "when";
"spread" -> "cons";
"load-data-readers" -> "data-reader-urls";
"filter" -> "when";
"*" -> "cast";
"keep" -> "chunk-append";
"proxy-super" -> "apply";
"distinct" -> "defn";
"zipmap" -> "defn";
"get-in" -> "defn";
"load-one" -> "*loaded-libs*";
"emit-deftype*" -> "defn-";
"constantly" -> "fn";
"generate-proxy" -> "method-sig";
"bean" -> "let";
"cond->>" -> "seq";
"find-protocol-method" -> "defn";
"emit-defrecord" -> "conj";
"send" -> "send-via";
"data-reader-var" -> "name";
"load-lib" -> "mapcat";
"process-annotation" -> "name";
"filter-key" -> "val";
"fn" -> "map?";
"ns-aliases" -> "ns";
"loop" -> "defmacro";
"with-in-str" -> "->";
"derive" -> "namespace";
"bigdec" -> "ratio?";
"with-open" -> "count";
"partition-by" -> "cons";
"str" -> "fn";
"destructure" -> "dissoc";
"bit-set" -> "defn";
"spit" -> "defn";
"generate-class" -> "name";
"emit-impl" -> "zipmap";
"map-indexed" -> "+";
"booleans" -> "seq";
"generate-class" -> "reduce1";
"map?" -> "instance?";
"load-libs" -> "prependss";
"into1" -> "conj";
"error-mode" -> "defn";
"validate-fields" -> "vector?";
"defn" -> "instance?";
"find-protocol-impl" -> "class";
"with-redefs" -> "apply";
"check-valid-options" -> "defn";
"case" -> "let";
"defrecord" -> "methods";
"emit-defrecord" -> "assoc";
">=" -> "next";
"decimal?" -> "instance?";
"spread" -> "first";
"proxy" -> "*compile-files*";
"ref" -> "when";
"dotimes" -> "count";
"pop-thread-bindings" -> "defn";
"emit-protocol" -> "defn-";
"load-one" -> "throw-if";
"empty?" -> "not";
"float?" -> "instance?";
"list*" -> "seq";
"supers" -> "loop";
"distinct?" -> "contains?";
"check-cyclic-dependency" -> "let";
"with-bindings*" -> "apply";
"print-map" -> "fn";
"long-array" -> "defn";
"fn" -> "or";
"re-find" -> "when";
"let" -> "count";
"associative?" -> "instance?";
"->VecSeq" -> "cond";
"pmap" -> "deref";
"ns" -> "remove";
"defmulti" -> "when-not";
"most-specific" -> "fn";
"defmacro" -> "let";
"defrecord" -> "namespace-munge";
"emit-defrecord" -> "boolean";
"condp" -> "gensym";
"map" -> "int";
"pvalues" -> "list";
"iterate" -> "lazy-seq";
"print-sequential" -> "defn-";
"tree-seq" -> "let";
"char-array" -> "defn";
"range" -> "let";
"underive" -> "make-hierarchy";
"bigint" -> "ratio?";
"re-seq" -> "find";
"generate-interface" -> "meta";
"destructure" -> "list";
"derive" -> "cons";
"loop" -> "=";
"keep-indexed" -> "chunk";
"mapv" -> "reduce";
"load-one" -> "find-ns";
"extend" -> "str";
"split-at" -> "drop";
"ns-publics" -> "defn";
"merge-with" -> "assoc";
"data-reader-var" -> "create-ns";
"sort-by" -> "fn";
"cond->>" -> "test";
"future-call" -> "reify";
"ns-unalias" -> "defn";
"destructure" -> "every?";
"ns-interns" -> "=";
"short-array" -> "defn";
"ref" -> "hash-map";
"+" -> "cast";
"loaded-libs" -> "deref";
"add-annotation" -> "cond";
"sorted?" -> "defn";
"binding-conveyor-fn" -> "apply";
"distinct" -> "when-let";
"parse-opts+specs" -> "disj";
"aset-long" -> "def-aset";
"find-protocol-impl" -> "filter";
"memoize" -> "let";
"ns" -> "list";
"mapv" -> "->";
"load-libs" -> "apply";
"assert-valid-fdecl" -> "remove";
"concat" -> "rest";
"def-aset" -> "apply";
"deftype" -> "symbol";
"load-lib" -> "ns-name";
"descendants" -> "get";
"proxy-call-with-super" -> "proxy-mappings";
"reify" -> "concat";
"load-data-reader-file" -> "contains?";
"binding" -> "seq";
"test" -> "meta";
"restart-agent" -> "hash-map";
"load-lib" -> "defn-";
"disj!" -> "key";
"load-one" -> "require";
"load" -> "let";
"with-in-str" -> "defmacro";
"distinct" -> "cons";
"bit-or" -> "defn";
"proxy" -> "concat";
"expand-method-impl-cache" -> "keys";
"atom" -> "setup-reference";
"valid-java-method-name" -> "=";
"pmap" -> "+";
"defmulti" -> "concat";
"proxy" -> "vector";
"reduce1" -> "val";
">" -> "next";
"get-super-and-interfaces" -> "defn-";
"defmulti" -> "vector";
"repeat" -> "cons";
"defstruct" -> "defmacro";
"some" -> "or";
"emit-protocol" -> "alter-meta!";
"unchecked-multiply" -> "defn";
"declare" -> "vary-meta";
"delay" -> "concat";
"load" -> "*ns*";
"normalize-slurp-opts" -> "defn-";
"generate-interface" -> "asm-type";
"aset-int" -> "def-aset";
"definterface" -> "vec";
"reduce1" -> "chunked-seq?";
"map" -> "lazy-seq";
"load-data-reader-file" -> "and";
"definline" -> "list";
"->Vec" -> "or";
"emit-extend-type" -> "parse-impls";
"add-annotation" -> "let";
"keep-indexed" -> "rest";
"bit-and" -> "and";
"emit-deftype*" -> "seq";
"bit-not" -> "not";
"case" -> "odd?";
"lazy-cat" -> "defmacro";
"find-var" -> "find";
"definterface" -> "concat";
"definterface" -> "vector";
"->Vec" -> "hash";
"subseq" -> "key";
"parse-impls" -> "defn-";
"dotimes" -> "<";
"maybe-min-hash" -> "distinct?";
"comp" -> "fn";
"keep" -> "seq";
"prep-hashes" -> "into1";
"into" -> "instance?";
"macroexpand" -> "let";
"emit-method-builder" -> "concat";
"subseq" -> "test";
"emit-extend-type" -> "list";
"future" -> "apply";
"doseq" -> "chunk-rest";
"gen-class" -> "map";
"keys" -> "defn";
"emit-method-builder" -> "vector";
"gen-interface" -> "str";
"bit-or" -> "or";
"amap" -> "let";
"generate-proxy" -> "pos?";
"->ArrayChunk" -> "deftype";
"boolean-array" -> "defn";
"condp" -> "second";
"every-pred" -> "every?";
"partition-by" -> "first";
"refer-clojure" -> "refer";
"re-find" -> "find";
"fn" -> "count";
"update-in" -> "apply";
"shift-mask" -> "bit-and";
"ns" -> "merge";
"partition-by" -> "=";
"max-key" -> "reduce1";
"emit-defrecord" -> "map";
"interleave" -> "let";
"emit-protocol" -> "seq";
"aset" -> "val";
"some" -> "defn";
"intern" -> "meta";
"unchecked-dec" -> "defn";
"emit-protocol" -> "intern";
"add-watch" -> "defn";
"nil?" -> "defn";
"seque" -> "int";
"subseq" -> "seq";
"find-field" -> "let";
"definline" -> "not";
"defn" -> "string?";
"refer" -> "when-not";
"defn" -> "second";
"rand-nth" -> "rand-int";
"prependss" -> "concat";
"find-protocol-impl" -> "reduce1";
"bigdec" -> "/";
"print-sequential" -> "seq";
"for" -> "chunk-rest";
"hash-set" -> "defn";
"prep-ints" -> "defn-";
"deftype" -> "import";
"send-via" -> "defn";
"expand-method-impl-cache" -> "nil?";
"fnext" -> "next";
"with-bindings" -> "fn";
"->VecSeq" -> "let";
"emit-protocol" -> "reduce1";
"condp" -> "cond";
"get-proxy-class" -> "let";
"maybe-destructured" -> "concat";
"slurp" -> "normalize-slurp-opts";
"ensure" -> "deref";
"intern" -> "the-ns";
"partition" -> "concat";
"let" -> "defmacro";
"load-lib" -> "key";
"flatten" -> "filter";
"send-off" -> "apply";
"locking" -> "concat";
"with-local-vars" -> "repeat";
"file-seq" -> "fn";
"cond->" -> "seq";
"defn-" -> "meta";
"merge" -> "reduce1";
"locking" -> "vector";
"when-first" -> "list";
"doseq" -> "when-let";
"ns" -> "list*";
"merge-hash-collisions" -> "==";
"for" -> "count";
"setup-reference" -> "hash-map";
"pr" -> "*out*";
"not-any?" -> "some";
"fn" -> "cons";
"=" -> "next";
"validate-generate-class-options" -> "let";
"with-local-vars" -> "let";
"assert" -> "*assert*";
"filter" -> "chunked-seq?";
"when-first" -> "assert-args";
"remove" -> "filter";
"generate-class" -> "replace";
"condp" -> "fn";
"sort" -> "seq";
"doseq" -> "nth";
"with-open" -> "=";
"process-annotation" -> "map?";
"the-class" -> "class?";
"some->>" -> "seq";
"declare" -> "concat";
"resultset-seq" -> "keys";
"aset-byte" -> "byte";
"emit-hinted-impl" -> "apply";
"doall" -> "dorun";
"compile" -> "load-one";
"sync" -> "defmacro";
"intern" -> "val";
"gen-interface" -> "defmacro";
"list?" -> "instance?";
"with-redefs-fn" -> "keys";
"map?" -> "fn";
"load-lib" -> "seq";
"emit-protocol" -> "nnext";
"fn" -> "str";
"destructure" -> "val";
"assert-args" -> "seq";
"dotimes" -> "first";
"add-annotation" -> "symbol?";
"every?" -> "seq";
"cond" -> "cons";
"defn" -> "fn";
"find" -> "key";
"with-redefs" -> "take-nth";
"chunk-buffer" -> "defn";
"==" -> "defn";
"for" -> "when-let";
"and" -> "concat";
"->Vec" -> "count";
"seque" -> "lazy-seq";
"dissoc!" -> "let";
"defmulti" -> "conj";
"even?" -> "integer?";
"not=" -> "defn";
"emit-deftype*" -> "name";
"dotimes" -> "=";
"proxy" -> "bases";
"def-aset" -> "aget";
"map" -> "when";
"assert" -> "when";
"chars" -> "list";
"and" -> "vector";
"spit" -> "str";
"drop-last" -> "fn";
"defmacro" -> "loop";
"replace" -> "fn";
"gensym" -> "defn";
"parse-opts+specs" -> "remove";
"load-all" -> "defn-";
"emit-hinted-impl" -> "keyword";
"zipmap" -> "first";
"->Vec" -> "set";
"get-in" -> "first";
"remove-method" -> "defn";
"definterface" -> "sigs";
"dorun" -> "defn";
"range" -> "loop";
"with-open" -> "defmacro";
"comp" -> "let";
"setup-reference" -> "when";
"load-all" -> "ref";
"fn" -> "<";
"check-valid-options" -> "str";
"dissoc" -> "key";
"validate-fields" -> "defn-";
"not-empty" -> "seq";
"dosync" -> "defmacro";
"expand-method-impl-cache" -> "fn";
"when-let" -> "let";
"pmap" -> "..";
"flatten" -> "seq";
"empty" -> "defn";
"print-meta" -> "pos?";
"with-loading-context" -> "apply";
"proxy" -> "assoc";
"vary-meta" -> "apply";
"parse-impls" -> "seq";
"fn?" -> "defn";
"parse-opts+specs" -> "parse-impls";
"emit-defrecord" -> "mapcat";
"with-redefs-fn" -> "doseq";
"deftype" -> "with-meta";
"defmacro" -> "next";
"memfn" -> "list";
"generate-class" -> "or";
"drop-while" -> "seq";
"defmulti" -> "assoc";
"print" -> "apply";
"sequential?" -> "defn";
"split-at" -> "take";
"build-positional-factory" -> "list";
"group-by" -> "assoc!";
"cond->" -> "test";
"defmethod" -> "defmacro";
"doseq" -> "count";
"->Vec" -> "comp";
"format" -> "defn";
"loop" -> "even?";
"group-by-sig" -> "assoc";
">0?" -> "defn";
"emit-protocol" -> "name";
"map" -> "chunk-first";
"->Vec" -> "nth";
"with-precision" -> "second";
"min" -> "reduce1";
"dotimes" -> "defmacro";
"defrecord" -> "declare";
"with-redefs-fn" -> "fn";
"check-valid-options" -> "first";
"take" -> "seq";
"find-protocol-impl" -> "defn";
"as->" -> "let";
"even?" -> "zero?";
"throw-if" -> "into-array";
"the-ns" -> "or";
"var?" -> "instance?";
"map" -> "every?";
"even?" -> "bit-and";
"pmap" -> "future";
"underive" -> "assoc";
"partial" -> "concat";
"->Vec" -> "cons";
"print-meta" -> "and";
"defrecord" -> "apply";
"assert-args" -> "nnext";
"merge-hash-collisions" -> "second";
"bases" -> "when";
"proxy-super" -> "list";
"proxy" -> "map";
"chunked-seq?" -> "defn";
"destructure" -> "gensym";
"import" -> "and";
"merge-hash-collisions" -> "keys";
"defn-" -> "list*";
"non-private-methods" -> "filter-methods";
"biginteger" -> "number?";
"->VecSeq" -> "next";
"or" -> "let";
"fn" -> "defmacro";
"generate-proxy" -> "group-by-sig";
"concat" -> "lazy-seq";
"array" -> "into-array";
"libspec?" -> "and";
"for" -> "<";
"while" -> "loop";
"into1" -> "conj!";
"<" -> "next";
"val" -> "defn";
"generate-class" -> "when-let";
"bytes" -> "concat";
"unchecked-inc-int" -> "defn";
"maybe-destructured" -> "conj";
"ffirst" -> "fn";
"add-annotations" -> "process-annotation";
"generate-class" -> "comp";
"definterface" -> "map";
"keyword?" -> "defn";
"print" -> "pr";
"generate-class" -> "nth";
"re-pattern" -> "defn";
"for" -> "peek";
"add-annotations" -> "is-annotation?";
"ns-name" -> "the-ns";
"generate-interface" -> "doseq";
"split-with" -> "take-while";
"ns" -> "not=";
"condp" -> "let";
"cond" -> "defmacro";
"read-line" -> "defn";
"imap-cons" -> "vec";
"load-data-readers" -> "reduce";
"extenders" -> "keys";
"sorted-map" -> "defn";
"find-protocol-impl" -> "or";
"ns-publics" -> "=";
"emit-method-builder" -> "map";
"->Vec" -> "<";
"keep-indexed" -> "lazy-seq";
"str" -> "next";
"with-out-str" -> "apply";
"prn" -> "apply";
"load-lib" -> "name";
"the-ns" -> "defn";
"amap" -> "loop";
"letfn" -> "interleave";
"load-one" -> "and";
"defn" -> "let";
"parents" -> "let";
"fn" -> "first";
"maybe-min-hash" -> "map";
"validate-generate-class-options" -> "valid-java-method-name";
"ns-aliases" -> "defn";
"->Vec" -> "peek";
"every-pred" -> "list*";
"when" -> "test";
"seque" -> "when";
"proxy" -> "vector?";
"for" -> "cons";
"memoize" -> "deref";
"asm-type" -> "or";
"->" -> "next";
"doto" -> "list";
"list*" -> "defn";
"find-field" -> "loop";
"emit-defrecord" -> "defn-";
"generate-class" -> "validate-generate-class-options";
"max-key" -> "defn";
"letfn" -> "cons";
"odd?" -> "even?";
"generate-interface" -> "some";
"if-let" -> "concat";
"areduce" -> "seq";
"add-doc-and-meta" -> "list";
"if-let" -> "vector";
"as->" -> "repeat";
"case" -> "vals";
"type" -> "class";
"doseq" -> "<";
"object-array" -> "defn";
"name" -> "string?";
"resultset-seq" -> "fn";
"the-class" -> "defn-";
"filter" -> "chunk-buffer";
"->VecSeq" -> "loop";
"memfn" -> "meta";
"emit-hinted-impl" -> "drop";
"for" -> "str";
"declare" -> "assoc";
"cond" -> "first";
"expand-method-impl-cache" -> "let";
"vector-of" -> "defn";
"generate-class" -> "count";
"assert" -> "list";
"vec" -> "to-array";
"case" -> "integer?";
"print-simple" -> "defn";
"add-doc-and-meta" -> "meta";
"cond->>" -> "count";
"case-map" -> "vector";
"time" -> "str";
"take-last" -> "seq";
"reify" -> "parse-opts+specs";
"min" -> "defn";
"derive" -> "get";
"resultset-seq" -> "let";
"emit-defrecord" -> "seq";
"nnext" -> "fn";
"non-private-methods" -> "defn-";
"with-redefs-fn" -> "zipmap";
"nary-inline" -> "fn";
"destructure" -> "second";
"merge-with" -> "key";
"range" -> "+";
"if-not" -> "defmacro";
"prn" -> "pr";
"load-all" -> "reduce1";
"subseq" -> "defn";
"def-aset" -> "hash-map";
"with-redefs-fn" -> "let";
"merge" -> "defn";
"keep-indexed" -> "chunk-first";
"alter-var-root" -> "defn";
"proxy-name" -> "repeat";
"disj" -> "key";
"for" -> "first";
"-cache-protocol-fn" -> "nil?";
"keep" -> "chunk-rest";
"sorted-set" -> "defn";
"get-method" -> "defn";
"generate-class" -> "find-field";
"agent" -> "defn";
"load-libs" -> "load-lib";
"letfn" -> "first";
"declare" -> "map";
"second" -> "first";
"partition-by" -> "take-while";
"error-handler" -> "defn";
"ancestors" -> "map";
"class" -> "nil?";
"for" -> "=";
"emit-protocol" -> "condp";
"isa?" -> "not";
"ns" -> "string?";
"descriptor" -> "defn-";
"proxy-name" -> "let";
"doseq" -> "defmacro";
"add-annotations" -> "doseq";
"proxy-call-with-super" -> "update-proxy";
"underive" -> "map";
"concat" -> "when";
"some" -> "first";
"with-redefs" -> "list";
"take-nth" -> "seq";
"printf" -> "print";
"with-open" -> "even?";
"merge-with" -> "seq";
"proxy-name" -> "*ns*";
"io!" -> "seq";
"generate-class" -> "cons";
"some->" -> "apply";
"map-indexed" -> "chunk-cons";
"agent-errors" -> "agent-error";
"emit-protocol" -> "or";
"generate-class" -> "ctor-sigs";
"mk-am" -> "seq";
"case" -> "with-meta";
"ns-interns" -> "and";
"load-libs" -> "not";
"fits-table?" -> "min";
"super-chain" -> "defn-";
"->Vec" -> "=";
"deftype" -> "vec";
"process-annotation" -> "add-annotation";
"add-doc-and-meta" -> "merge";
"comp" -> "loop";
"merge" -> "or";
"sigs" -> "list";
"parse-opts" -> "keyword?";
"defonce" -> "seq";
"load-libs" -> "remove";
"import" -> "rest";
"bit-and-not" -> "reduce1";
"deftype" -> "concat";
"future" -> "hash-map";
"dissoc!" -> "next";
"for" -> "defmacro";
"generate-class" -> "str";
"agent" -> "or";
"merge-hash-collisions" -> "fn";
"defprotocol" -> "name";
"with-precision" -> "let";
"deftype" -> "vector";
"emit-defrecord" -> "class";
"letfn" -> "defmacro";
"disj!" -> "defn";
"data-reader-var" -> "namespace";
"let" -> "even?";
"keep" -> "defn";
"concat" -> "chunk-first";
"ns-resolve" -> "when-not";
"amap" -> "unchecked-inc";
"doseq" -> "first";
"replicate" -> "take";
"compile" -> "*compile-files*";
"comp" -> "next";
"print" -> "*print-readably*";
"find-protocol-impl" -> "when-let";
"await-for" -> "defn";
"juxt" -> "reduce1";
"doubles" -> "list";
"filterv" -> "persistent!";
"doseq" -> "=";
"case" -> "last";
"bit-test" -> "defn";
"gensym" -> "str";
"drop" -> "seq";
"re-seq" -> "fn";
"ns" -> "fn";
"bean" -> "..";
"binding" -> "count";
"print-meta" -> "*print-dup*";
"derive" -> "and";
"read" -> "*in*";
"prep-ints" -> "or";
"set-agent-send-off-executor!" -> "defn";
"ex-data" -> "defn";
"subseq" -> "when-let";
"flatten" -> "defn";
"maybe-min-hash" -> "inc";
"generate-proxy" -> "pop";
"->Vec" -> "unchecked-add-int";
"not-empty" -> "defn";
"generate-class" -> "=";
"def-aset" -> "list";
"==" -> "first";
"drop-while" -> "defn";
"coll?" -> "defn";
"find" -> "defn";
"bean" -> "zero?";
"load-lib" -> "or";
"print-sequential" -> "when-let";
"memfn" -> "gensym";
"mk-am" -> "aset";
"case" -> "seq?";
"not=" -> "=";
"emit-defrecord" -> "name";
"pr-str" -> "with-out-str";
"nary-inline" -> "let";
"load-data-reader-file" -> "when";
"group-by-sig" -> "defn-";
"remove" -> "defn";
"ns-interns" -> "ns-map";
"cond->>" -> "interleave";
"extend" -> "partition";
"await-for" -> "send";
"->VecSeq" -> "+";
"or" -> "next";
"class?" -> "instance?";
"not" -> "defn";
"get" -> "map";
"clojure-version" -> "*clojure-version*";
"if-let" -> "vector?";
"await1" -> "pos?";
"dissoc" -> "defn";
"keep" -> "count";
"get-in" -> "get";
"destructure" -> "cond";
"disj!" -> "set";
"generate-proxy" -> "into1";
"into1" -> "reduce1";
"await-for" -> "count";
"mapv" -> "persistent!";
"ns-refers" -> "the-ns";
"sort" -> "defn";
"emit-method-builder" -> "defn-";
"defrecord" -> "emit-defrecord";
"distinct?" -> "not";
"biginteger" -> "ratio?";
"asm-type" -> "str";
"pvalues" -> "fn";
"reduce1" -> "let";
"->Vec" -> ">";
"nthnext" -> "seq";
"future" -> "list";
"seq" -> "fn";
"map-indexed" -> "chunk-append";
"aget" -> "class";
"emit-protocol" -> "count";
"ancestors" -> "class?";
"maybe-min-hash" -> "defn-";
"destructure" -> "fn";
"find-keyword" -> "ns";
"require" -> "load-libs";
"merge-with" -> "reduce1";
"sigs" -> "meta";
"keep" -> "when-let";
"derive" -> "contains?";
"flush" -> "defn";
"->" -> "with-meta";
"generate-interface" -> "let";
"group-by" -> "conj";
"time" -> "defmacro";
"map" -> "chunked-seq?";
"satisfies?" -> "defn";
"every?" -> "defn";
"get-proxy-class" -> "deref";
"chunk-next" -> "defn";
"seque" -> "agent";
"pmap" -> "map";
"promise" -> "pos?";
"defonce" -> "name";
"defn" -> "next";
"bound-fn" -> "defmacro";
"merge-hash-collisions" -> "let";
"is-runtime-annotation?" -> "boolean";
"ints" -> "concat";
"generate-interface" -> "dotimes";
"await1" -> "await";
"ns-refers" -> "val";
"with-loading-context" -> "hash-map";
"print-dup" -> "fn";
"println-str" -> "defn";
"prependss" -> "defn-";
"supers" -> "bases";
"-cache-protocol-fn" -> "find-protocol-method";
"the-ns" -> "str";
"list*" -> "cons";
"ref-set" -> "val";
"keyword" -> "ns";
"assoc" -> "val";
"type" -> "or";
"juxt" -> "defn";
"use" -> "defn";
"keep" -> "cons";
"cond->" -> "count";
"refer-clojure" -> "list";
"emit-deftype*" -> "str";
"set?" -> "defn";
"ns-refers" -> "instance?";
"alias" -> "defn";
"->Vec" -> "deftype";
"rand-nth" -> "defn";
"make-array" -> "defn";
"generate-proxy" -> "make-array";
"test" -> "let";
"->VecSeq" -> "bit-and";
"generate-class" -> ">";
"doseq" -> "even?";
"promise" -> "and";
"->Vec" -> "cast";
"re-seq" -> "let";
"bound-fn*" -> "fn";
"ns" -> "let";
"doto" -> "gensym";
"emit-defrecord" -> "into";
"-cache-protocol-fn" -> "let";
"vector?" -> "instance?";
"distinct" -> "contains?";
"add-annotation" -> "seq?";
"find-keyword" -> "name";
"future?" -> "instance?";
"load-data-reader-file" -> "not";
"map-indexed" -> "inc";
"prn" -> "when";
"build-positional-factory" -> "for";
"->>" -> "list";
"resultset-seq" -> "next";
"definline" -> "fn";
"unchecked-byte" -> "defn";
"maybe-min-hash" -> "filter";
"deftype" -> "split-at";
"take" -> "defn";
"print-simple" -> "str";
"loop" -> "drop";
"aset-double" -> "def-aset";
"reify" -> "seq";
"set-error-handler!" -> "defn";
"parse-opts+specs" -> "keys";
"->" -> "seq?";
"-reset-methods" -> "keyword";
"trampoline" -> "defn";
"ns" -> "dosync";
"emit-hinted-impl" -> "list";
"map" -> "chunk-buffer";
"when-not" -> "list";
"emit-protocol" -> "str";
"repeatedly" -> "defn";
"zipmap" -> "and";
"proxy" -> "seq";
"case" -> "concat";
"for" -> "even?";
"print-meta" -> "*print-readably*";
"proxy" -> "intern";
"defmulti" -> "seq";
"macroexpand" -> "identical?";
"->Vec" -> ">=";
"case" -> "vector";
"protected-final-methods" -> "and";
"cond->>" -> "defmacro";
"filter-key" -> "loop";
"type" -> "defn";
"every-pred" -> "fn";
"apply" -> "seq";
"get-proxy-class" -> "generate-proxy";
"sort" -> "comp";
"assert-valid-fdecl" -> "let";
"delay" -> "seq";
"find-protocol-method" -> "get";
"emit-method-builder" -> "-cache-protocol-fn";
"vector-of" -> "first";
"defmacro" -> "vec";
"mapv" -> "apply";
"load" -> "when-not";
"floats" -> "list";
"filter" -> "let";
"find-protocol-impl" -> "first";
"into-array" -> "type";
"load-libs" -> "keyword?";
"ns-refers" -> "not=";
"counted?" -> "instance?";
"deftype" -> "map";
"into1" -> "transient";
"shift-mask" -> "defn-";
"defrecord" -> "validate-fields";
"filter" -> "dotimes";
"compare-and-set!" -> "defn";
"to-array-2d" -> "let";
"assert-same-protocol" -> "*out*";
"definterface" -> "seq";
"import" -> "into1";
"generate-class" -> "overload-name";
"add-annotations" -> "let";
"with-in-str" -> "apply";
"bit-and-not" -> "defn";
"print-meta" -> "*print-meta*";
"filter-key" -> "next";
"prep-hashes" -> "==";
"ns-map" -> "ns";
"to-array" -> "defn";
"hash-map" -> "defn";
"intern" -> "let";
"->Vec" -> "bit-shift-left";
"chunk-first" -> "defn";
"with-loading-context" -> "list";
"emit-method-builder" -> "seq";
"generate-proxy" -> "when";
"destructure" -> "let";
"case-map" -> "map";
"with-precision" -> "next";
"alength" -> "defn";
"->VecSeq" -> "identical?";
".." -> "list";
"emit-defrecord" -> "hash";
"->VecSeq" -> "vec";
"cycle" -> "concat";
"bit-shift-right" -> "defn";
"destructure" -> "symbol?";
"fn" -> "maybe-destructured";
"sync" -> "apply";
"seque" -> "instance?";
"distinct" -> "rest";
"gen-interface" -> "apply";
"vary-meta" -> "meta";
"defmacro" -> "conj";
"parse-opts+specs" -> "fn";
"atom" -> "defn";
"ref" -> "let";
"keep-indexed" -> "chunked-seq?";
"binding" -> "first";
"->Vec" -> "pos?";
"print-meta" -> "when";
"pr" -> "pr-on";
"case" -> "assoc";
"nary-inline" -> "*unchecked-math*";
"merge-hash-collisions" -> "next";
"load-lib" -> "str";
"pop" -> "defn";
"assert-args" -> "str";
"rand-nth" -> "nth";
"aclone" -> "defn";
"re-find" -> "let";
"make-array" -> "nth";
"aset-boolean" -> "def-aset";
"eval" -> "defn";
"with-local-vars" -> "..";
"defrecord" -> "list";
"defn" -> "last";
"the-ns" -> "find-ns";
"map-indexed" -> "seq";
"descendants" -> "not-empty";
"shuffle" -> "let";
"take" -> "when-let";
"load-data-reader-file" -> "binding";
"newline" -> "system-newline";
"ns-publics" -> "and";
"rational?" -> "or";
"init-proxy" -> "proxy";
"merge-with" -> "or";
"maybe-destructured" -> "seq";
"line-seq" -> "defn";
"load-lib" -> "load";
"emit-defrecord" -> "replace";
"io!" -> "or";
"take-last" -> "defn";
"partition-by" -> "drop";
"partition" -> "seq";
"nthrest" -> "loop";
"bound-fn*" -> "let";
"cond->" -> "interleave";
"->Vec" -> "get";
"->Vec" -> "<=";
"underive" -> "key";
"while" -> "concat";
"locking" -> "seq";
"generate-class" -> "methods";
"->>" -> "meta";
"while" -> "vector";
"overload-name" -> "map";
"print" -> "binding";
"keyword" -> "name";
"disj!" -> "first";
"bean" -> "conj";
"keep" -> "first";
"nnext" -> "next";
"double" -> "defn";
"definline" -> "let";
"fn" -> "and";
"refer" -> "ns";
"imap-cons" -> "defn-";
"binding" -> "defmacro";
"with-open" -> "subvec";
"cond->" -> "->";
"frequencies" -> "fn";
"dotimes" -> "apply";
"max-key" -> ">";
"some->>" -> "interleave";
"load-one" -> "when";
"ctor-sigs" -> "vector";
"create-struct" -> "keys";
"re-pattern" -> "compile";
"declare" -> "seq";
"into1" -> "defn";
"promise" -> "reify";
"emit-defrecord" -> "condp";
"complement" -> "apply";
"generate-class" -> "supers";
"memoize" -> "assoc";
"deftype" -> "parse-opts+specs";
"with-out-str" -> "list";
"->" -> "concat";
"proxy" -> "name";
"concat" -> "chunked-seq?";
"defmulti" -> "name";
"rand-nth" -> "count";
"make-array" -> "count";
"contains?" -> "key";
"emit-protocol" -> "first";
"amap" -> "concat";
"every-pred" -> "let";
"bean" -> "assoc";
"emit-extend-type" -> "let";
"underive" -> "seq";
"rational?" -> "decimal?";
"amap" -> "vector";
"generate-proxy" -> "dissoc";
"take-nth" -> "defn";
"memfn" -> "fn";
"and" -> "seq";
"rational?" -> "defn";
"def-aset" -> "val";
"prn" -> "flush";
"defmulti" -> "global-hierarchy";
"merge-with" -> "defn";
"deftype" -> "build-positional-factory";
"defn" -> "with-meta";
"generate-proxy" -> "not";
"interleave" -> "concat";
"group-by-sig" -> "reduce1";
"add-annotations" -> "symbol?";
"merge-hash-collisions" -> "loop";
"disj" -> "defn";
"realized?" -> "defn";
"reduce1" -> "next";
"emit-defrecord" -> "or";
"definterface" -> "name";
"delay?" -> "defn";
"loop" -> "take-nth";
"generate-class" -> "method-sig";
"num" -> "defn";
"ns" -> "commute";
"bytes" -> "definline";
"generate-proxy" -> "remove";
"take-while" -> "seq";
"for" -> "chunk";
"bigdec" -> "decimal?";
"most-specific" -> "isa?";
"map" -> "fn";
"spit" -> "apply";
"underive" -> "reduce1";
"case-map" -> "defn-";
"memfn" -> "let";
"char?" -> "instance?";
"with-precision" -> "*math-context*";
"mk-bound-fn" -> "fn";
"nthnext" -> "defn";
"bigdec" -> "defn";
"emit-defrecord" -> "count";
"mod" -> "defn";
"ns-publics" -> "ns-map";
"isa?" -> "some";
"select-keys" -> "find";
"build-positional-factory" -> "let";
"is-runtime-annotation?" -> "defn-";
"release-pending-sends" -> "defn";
"merge" -> "identity";
"into" -> "with-meta";
"underive" -> "global-hierarchy";
"partition" -> "doall";
"filter-methods" -> "let";
"proxy-super" -> "fn";
"dissoc" -> "first";
"proxy" -> "proxy-name";
"case" -> "prep-hashes";
"destructure" -> "next";
"check-valid-options" -> "apply";
"int" -> "defn";
"emit-defrecord" -> "set";
"interleave" -> "conj";
"flatten" -> "tree-seq";
"if-let" -> "seq";
"defn" -> "butlast";
"non-private-methods" -> "or";
"parse-opts+specs" -> "let";
"with-out-str" -> "binding";
"pmap" -> "seq";
"slurp" -> "let";
"generate-class" -> "partial";
"ns-refers" -> "fn";
"partition-by" -> "lazy-seq";
"restart-agent" -> "let";
"with-in-str" -> "*in*";
"with-bindings" -> "concat";
"print-method" -> "class";
"emit-extend-type" -> "extend";
"make-array" -> "cons";
"line-seq" -> "when-let";
"assert-same-protocol" -> "defn-";
"aset-boolean" -> "boolean";
"expand-method-impl-cache" -> "*";
"with-bindings" -> "vector";
"defmacro" -> "vector?";
"aset-short" -> "short";
"load-libs" -> "nil?";
"cond->>" -> "even?";
"clojure-version" -> "defn";
"drop" -> "defn";
"with-local-vars" -> "concat";
"when-first" -> "let";
"find-protocol-impl" -> "supers";
"pr" -> "defn";
"with-local-vars" -> "vector";
"vector?" -> "fn";
"->Vec" -> "and";
"find-keyword" -> "defn";
"ns" -> "next";
"check-valid-options" -> "rest";
"get" -> "key";
"seque" -> "nil?";
"merge-hash-collisions" -> "vals";
"aget" -> "defn";
"emit-impl" -> "map";
"emit-defrecord" -> "comp";
"assert-args" -> "first";
"println" -> "defn";
"range" -> "chunk-cons";
"every?" -> "first";
"dec" -> "defn";
"clear-agent-errors" -> "restart-agent";
"when" -> "cons";
"generate-class" -> "pos?";
"get-super-and-interfaces" -> "first";
"bigint" -> "decimal?";
"mod" -> "or";
"take" -> "cons";
"for" -> "partition";
"lazy-cat" -> "lazy-seq";
"load" -> "conj";
"import" -> "list";
"load-one" -> "not";
"check-cyclic-dependency" -> "map";
"re-matches" -> "when";
"cond->" -> "defmacro";
"normalize-slurp-opts" -> "first";
"bigint" -> "defn";
"binding" -> "push-thread-bindings";
"distinct?" -> "not=";
"slurp" -> "with-open";
"bytes" -> "seq";
"repeatedly" -> "cons";
"disj" -> "set";
"unchecked-char" -> "defn";
"assoc" -> "second";
"some->" -> "list";
"load" -> "root-directory";
"add-classpath" -> "println";
"keep-indexed" -> "chunk-buffer";
"to-array-2d" -> "loop";
"array-map" -> "defn";
"take-nth" -> "when-let";
"struct" -> "defn";
"rem" -> "num";
"parse-impls" -> "first";
"validate-fields" -> "str";
"drop-while" -> "first";
"doto" -> "fn";
"some->>" -> "defmacro";
"dorun" -> "pos?";
"vec" -> "instance?";
"fn" -> "apply";
"areduce" -> "<";
"imap-cons" -> "seq";
"when-let" -> "concat";
"partition" -> "nthrest";
"destructure" -> "loop";
"when-let" -> "vector";
"load-libs" -> "doseq";
"ancestors" -> "reduce1";
"bigdec" -> "float?";
"assert-args" -> "defmacro";
"ancestors" -> "global-hierarchy";
"ratio?" -> "instance?";
"to-array-2d" -> "next";
"emit-deftype*" -> "namespace-munge";
"ns" -> "deref";
"global-hierarchy" -> "make-hierarchy";
"take-nth" -> "cons";
"doto" -> "let";
"take" -> "first";
"defprotocol" -> "defmacro";
"loop" -> "assert-args";
"derive" -> "when";
"doseq" -> "apply";
"binding-conveyor-fn" -> "fn";
"load-lib" -> "throw-if";
"deftype" -> "seq";
"add-annotation" -> "vector?";
"reversible?" -> "instance?";
"load-lib" -> "printf";
"*loaded-libs*" -> "ref";
"dorun" -> "and";
"ifn?" -> "defn";
"as->" -> "concat";
"map" -> "let";
"assoc!" -> "val";
"as->" -> "vector";
"seque" -> "fn";
"load-data-reader-file" -> "not=";
"with-bindings*" -> "pop-thread-bindings";
"distinct" -> "lazy-seq";
"generate-interface" -> "+";
"map" -> "dotimes";
"clojure-version" -> "when-let";
"repeat" -> "lazy-seq";
"assoc" -> "fn";
"mk-am" -> "str";
"proxy" -> "or";
"or" -> "concat";
"or" -> "vector";
"areduce" -> "defmacro";
"binding" -> "even?";
"for" -> "apply";
"setup-reference" -> "let";
"definline" -> "split-with";
"emit-protocol" -> "namespace-munge";
"load-lib" -> "find-ns";
"generate-interface" -> "into-array";
"xml-seq" -> "string?";
"promise" -> "atom";
"set-error-mode!" -> "defn";
"ns-map" -> "defn";
"ns-refers" -> "let";
"keep-indexed" -> "nil?";
"select-keys" -> "meta";
"when" -> "defmacro";
"with-redefs" -> "fn";
"get-proxy-class" -> "bases";
"ensure" -> "ref";
"find-protocol-impl" -> "get";
"overload-name" -> "defn-";
"asm-type" -> "prim->class";
"load-data-reader-file" -> "data-reader-var";
"line-seq" -> "cons";
"some-fn" -> "list*";
"prep-hashes" -> "let";
"definterface" -> "or";
"condp" -> "concat";
"ints" -> "definline";
"supers" -> "class";
"emit-defrecord" -> "->";
"with-bindings" -> "with-bindings*";
"ns" -> "symbol";
"condp" -> "vector";
"generate-class" -> "contains?";
"range" -> "chunk-append";
"keep-indexed" -> "letfn";
"for" -> "rest";
"keyword" -> "defn";
"emit-defrecord" -> "cons";
"throw-if" -> "defn-";
"conj" -> "fn";
"load-lib" -> "*loaded-libs*";
"is-annotation?" -> "and";
"reverse" -> "conj";
"print-meta" -> "meta";
"thread-bound?" -> "every?";
"byte-array" -> "defn";
"method-sig" -> "seq";
"subvec" -> "defn";
"namespace-munge" -> "ns";
"sigs" -> "fn";
"rsubseq" -> "let";
"emit-method-builder" -> "or";
"emit-deftype*" -> "methods";
"split-with" -> "drop-while";
"tree-seq" -> "mapcat";
"emit-defrecord" -> "str";
"->Vec" -> "reify";
"interleave" -> "map";
"swap!" -> "defn";
"apply" -> "defn";
"->Vec" -> "subvec";
"loop" -> "list";
"extend" -> "when";
"supers" -> "seq";
"the-class" -> "str";
"defmulti" -> "map?";
"seq?" -> "instance?";
"re-seq" -> "re-matcher";
"expand-method-impl-cache" -> "vec";
"clojure-version" -> "count";
"future-call" -> "let";
"ancestors" -> "defn";
"io!" -> "defmacro";
"iterator-seq" -> "defn";
"defstruct" -> "list";
"filter-methods" -> "loop";
"defn" -> "conj";
"mk-am" -> "defmacro";
"emit-defrecord" -> "first";
"underive" -> "defn";
"alength" -> "array";
"->Vec" -> "dec";
"destructure" -> "with-meta";
"refer" -> "defn";
"generate-class" -> "apply";
"for" -> "int";
"data-reader-urls" -> "..";
"load-all" -> "*loaded-libs*";
"parents" -> "bases";
"load-libs" -> "repeat";
"integer?" -> "instance?";
"defonce" -> "defmacro";
"char?" -> "fn";
"emit-defrecord" -> "=";
"lazy-cat" -> "list";
"gen-interface" -> "hash-map";
"promise" -> "when";
"->Vec" -> "aget";
"check-valid-options" -> "disj";
"slurp" -> "loop";
"libspec?" -> "keyword?";
"send-off" -> "send-via";
"parse-opts" -> "loop";
"deftype" -> "name";
"deliver" -> "val";
"chunk" -> "defn";
"binding-conveyor-fn" -> "let";
"ints" -> "seq";
"dotimes" -> "when";
"load-libs" -> "let";
"subvec" -> "count";
"validate-generate-class-options" -> "map";
"interpose" -> "defn";
"filter-methods" -> "next";
"load-libs" -> "complement";
"odd?" -> "not";
"not=" -> "apply";
"seque" -> "let";
"cond->>" -> "partition";
"cond->" -> "even?";
"number?" -> "instance?";
"defn" -> "assoc";
"update-proxy" -> "defn";
"escape-class-name" -> "..";
"contains?" -> "defn";
"time" -> "apply";
"proxy-name" -> "concat";
"when-let" -> "vector?";
"->Vec" -> "int";
"super-chain" -> "cons";
"emit-impl" -> "defn-";
"subseq" -> "take-while";
"gen-class" -> "defmacro";
"take-nth" -> "first";
"find-protocol-impl" -> "and";
"repeat" -> "take";
"replace" -> "assoc";
"assoc" -> "let";
"defmulti" -> "count";
"prep-ints" -> "case-map";
"proxy" -> "get-proxy-class";
"io!" -> "first";
"disj" -> "first";
"merge-hash-collisions" -> "->>";
"ns-resolve" -> "ns";
"with-redefs" -> "zipmap";
"await-for" -> "await";
"dissoc!" -> "map";
"map-indexed" -> "defn";
"refer" -> "or";
"check-cyclic-dependency" -> "defn-";
"lazy-seq" -> "defmacro";
"root-directory" -> "let";
"expand-method-impl-cache" -> "assoc";
"partition-all" -> "seq";
"maybe-destructured" -> "defn";
"clojure-version" -> "str";
"partition" -> "defn";
"bases" -> "let";
"load-lib" -> "require";
"sort" -> "compare";
"await1" -> "when";
"send-via" -> "*agent*";
"promise" -> "compare-and-set!";
"doseq" -> "int";
"emit-defrecord" -> "case";
"overload-name" -> "seq";
"sigs" -> "let";
"with-precision" -> "concat";
"add-annotation" -> "class?";
"with-in-str" -> "list";
"concat" -> "fn";
"with-precision" -> "vector";
"with-local-vars" -> "vector?";
"ex-info" -> "map";
"persistent!" -> "defn";
"re-find" -> "re-matcher";
"map-indexed" -> "chunk-rest";
"resultset-seq" -> "distinct?";
"hash-combine" -> "defn";
"resolve" -> "defn";
"await" -> "defn";
"pr" -> "first";
"merge-hash-collisions" -> "concat";
"proxy" -> "cons";
"expand-method-impl-cache" -> "map";
"parse-opts+specs" -> "deref";
"merge-hash-collisions" -> "update-in";
"defmacro" -> "seq";
"extend" -> "alter-var-root";
"some->" -> "gensym";
"concat" -> "let";
"load-lib" -> "*loading-verbosely*";
"apply" -> "cons";
"proxy-super" -> "proxy-call-with-super";
"bean" -> "key";
"<=" -> "defn";
"get" -> "defn";
"seq?" -> "fn";
"emit-extend-protocol" -> "list";
"sync" -> "list";
"condp" -> "split-at";
"generate-proxy" -> "doseq";
"load" -> "ns-name";
"map-indexed" -> "count";
"doto" -> "next";
"partition-all" -> "nthrest";
"proxy" -> "str";
"for" -> "pop";
"group-by" -> "transient";
"derive" -> "alter-var-root";
"cond->>" -> "apply";
"ns" -> "with-loading-context";
"generate-proxy" -> "bit-or";
"ns" -> "vary-meta";
"xml-seq" -> "complement";
"load-all" -> "require";
"keep" -> "chunk";
"complement" -> "not";
"aclone" -> "array";
"into" -> "conj";
"generate-class" -> "non-private-methods";
"partition" -> "count";
"filter-key" -> "assoc";
"overload-name" -> "escape-class-name";
"take-while" -> "defn";
"char" -> "defn";
"defn" -> "vector?";
"min-key" -> "reduce1";
"ns-interns" -> "the-ns";
"partition-all" -> "doall";
"defn-" -> "with-meta";
"parse-impls" -> "take-while";
"with-in-str" -> "binding";
"replicate" -> "repeat";
"keep-indexed" -> "let";
"nary-inline" -> "concat";
"replace" -> "vector?";
"butlast" -> "fn";
"pos?" -> "defn";
"->VecSeq" -> "inc";
"definterface" -> "str";
"assert-valid-fdecl" -> "seq?";
"with-open" -> "list";
"build-positional-factory" -> "symbol";
"protected-final-methods" -> "not";
"non-private-methods" -> "=";
"emit-hinted-impl" -> "fn";
"->Vec" -> "aclone";
"add-annotation" -> "defn-";
"bean" -> "seq";
"dosync" -> "list";
"comparator" -> "defn";
"map-indexed" -> "when-let";
"fn" -> "when";
"rand-int" -> "rand";
"->Vec" -> "pop";
"keep-indexed" -> "dotimes";
"pmap" -> "defn";
">1?" -> "defn";
"load-string" -> "load-reader";
"emit-protocol" -> "and";
"case" -> "test";
"with-open" -> "assert-args";
"some-fn" -> "some";
"emit-method-builder" -> "str";
"defmethod" -> "list";
"ctor-sigs" -> "defn-";
"partition" -> "when-let";
"->Vec" -> "bit-shift-right";
"max" -> "reduce1";
"-cache-protocol-fn" -> "when-not";
"dotimes" -> "list";
"nfirst" -> "first";
"parse-opts+specs" -> "vals";
"ancestors" -> "set";
"ns-interns" -> "val";
"merge-with" -> "identity";
"force" -> "defn";
"partial" -> "defn";
"print-sequential" -> "and";
"prependss" -> "cons";
"generate-proxy" -> "second";
"load-data-reader-file" -> "fn";
"cond" -> "when";
"let" -> "list";
"destructure" -> "seq?";
"mod" -> "=";
"generate-proxy" -> "keys";
"fnil" -> "defn";
"print-map" -> "defn-";
"group-by-sig" -> "peek";
"generate-proxy" -> "for";
"drop-last" -> "map";
"case" -> "seq";
"dotimes" -> "assert-args";
"check-valid-options" -> "when";
"for" -> "lazy-seq";
"replace" -> "map";
"loaded-libs" -> "defn";
"assoc!" -> "second";
"re-groups" -> "let";
"dorun" -> "dec";
"refer" -> "set";
"most-specific" -> "defn-";
"with-loading-context" -> "fn";
"let" -> "assert-args";
"load-lib" -> "pos?";
"generate-class" -> "int";
"bound?" -> "defn";
"emit-extend-protocol" -> "parse-impls";
"rsubseq" -> "next";
"deref" -> "instance?";
"find-field" -> "defn-";
"load-lib" -> "contains?";
"isa?" -> "loop";
"proxy" -> "defmacro";
"generate-class" -> "pop";
"cons" -> "seq";
"->" -> "seq";
"defmulti" -> "defmacro";
"method-sig" -> "defn";
"conj" -> "next";
"destructure" -> "concat";
"agent" -> "apply";
"for" -> "when";
"maybe-min-hash" -> "first";
"libspec?" -> "second";
"amap" -> "seq";
"delay" -> "defmacro";
"type" -> "get";
"case" -> "reduce1";
"sigs" -> "next";
"doseq" -> "chunk-first";
"print-map" -> "seq";
"*'" -> "reduce1";
"emit-protocol" -> "rest";
"if-let" -> "count";
"ancestors" -> "cons";
"emit-protocol" -> "keyword";
"group-by" -> "defn";
"resultset-seq" -> "map";
"interleave" -> "seq";
"binding" -> "apply";
"parents" -> "class?";
"cond" -> "list";
"frequencies" -> "assoc!";
"defmacro" -> "name";
"load-lib" -> "and";
"load-string" -> "defn";
"definterface" -> "defmacro";
"pcalls" -> "defn";
"memfn" -> "with-meta";
"with-redefs-fn" -> "map";
"load-lib" -> "refer";
"interpose" -> "interleave";
"take-while" -> "when-let";
"some" -> "when";
"generate-class" -> "merge-with";
"supers" -> "defn";
"emit-extend-type" -> "emit-hinted-impl";
"ns" -> "concat";
"loop" -> "gensym";
"root-directory" -> "root-resource";
"load-data-reader-file" -> "with-open";
"underive" -> "cons";
"cast" -> "defn";
"namespace-munge" -> "defn";
"merge-hash-collisions" -> "conj";
"sorted-set-by" -> "defn";
"seque" -> "loop";
"cycle" -> "seq";
"validate-generate-class-options" -> "defn-";
"->Vec" -> "when";
"some-fn" -> "fn";
"last" -> "fn";
"generate-proxy" -> "fn";
"cond->" -> "partition";
"->VecSeq" -> "seq";
"proxy-name" -> "map";
"maybe-min-hash" -> "range";
"await" -> "send";
"generate-class" -> "into1";
"compare" -> "defn";
"add-annotation" -> "class";
"ns-imports" -> "ns";
"for" -> "chunk-first";
"find-protocol-impl" -> "super-chain";
"future-cancelled?" -> "defn";
"fn" -> "not";
"build-positional-factory" -> "+";
"implements?" -> "defn-";
"shift-mask" -> "->";
"proxy" -> "first";
"while" -> "test";
"take" -> "pos?";
"emit-defrecord" -> "methods";
"defmulti" -> "first";
"methods" -> "defn";
"re-seq" -> "re-groups";
"refer" -> "str";
"find-field" -> "filter";
"dec'" -> "defn";
"aget" -> "array";
"emit-protocol" -> "emit-method-builder";
"generate-class" -> "the-class";
"emit-hinted-impl" -> "zipmap";
"bit-shift-left" -> "defn";
"defmulti" -> "=";
"require" -> "defn";
"future-call" -> "deref-future";
"await" -> "count";
"merge-hash-collisions" -> "assoc";
"drop-while" -> "and";
"bean" -> "name";
"emit-hinted-impl" -> "let";
"even?" -> "defn";
"doseq" -> "when";
"reset!" -> "defn";
"assoc" -> "next";
"print-map" -> "key";
"with-meta" -> "fn";
"bean" -> "reduce1";
"prn-str" -> "prn";
"while" -> "seq";
"emit-defrecord" -> "namespace-munge";
"map-indexed" -> "cons";
"prn-str" -> "with-out-str";
"select-keys" -> "keys";
"maybe-destructured" -> "->";
"sigs" -> "loop";
"shutdown-agents" -> "defn";
"maybe-destructured" -> "cons";
"with-redefs" -> "next";
"reduce-kv" -> "defn";
"time" -> "double";
"ns-interns" -> "instance?";
"libspec?" -> "nil?";
"keep" -> "rest";
"emit-protocol" -> "apply";
"partition" -> "cons";
"emit-method-builder" -> "first";
"reify" -> "defmacro";
"some->" -> "nil?";
"prep-ints" -> "shift-mask";
"load-data-reader-file" -> "let";
"fn" -> "list";
">=" -> "defn";
"pvalues" -> "concat";
"resultset-seq" -> "create-struct";
"import" -> "second";
"reduced" -> "defn";
"add-annotation" -> "name";
"merge-hash-collisions" -> "map";
"partition-all" -> "defn";
"supers" -> "set";
"ensure" -> "defn";
"generate-class" -> "make-array";
"load-data-reader-file" -> "symbol?";
"print-str" -> "with-out-str";
"prefer-method" -> "defn";
"expand-method-impl-cache" -> "defn-";
"enumeration-seq" -> "defn";
"emit-defrecord" -> "resolve";
"fn" -> "meta";
"dorun" -> "when";
"doseq" -> "list";
"declare" -> "defmacro";
"flatten" -> "rest";
"ns-resolve" -> "defn";
"seque" -> "deref";
"when-let" -> "seq";
"drop-while" -> "rest";
"empty" -> "when";
"cond->" -> "apply";
"printf" -> "defn";
"map-indexed" -> "first";
"clear-agent-errors" -> "defn";
"doseq" -> "assert-args";
"assert-same-protocol" -> "*err*";
"agent-errors" -> "defn";
"concat" -> "next";
"distinct?" -> "loop";
"and" -> "defmacro";
"derive" -> "instance?";
"maybe-destructured" -> "first";
"emit-protocol" -> "dec";
"compile" -> "defn";
"subs" -> "defn";
"unchecked-add-int" -> "defn";
"merge-with" -> "get";
"destructure" -> "conj";
"set" -> "seq";
"->Vec" -> "remove";
"push-thread-bindings" -> "defn";
"array" -> "defn";
"if-not" -> "not";
"reset-meta!" -> "defn";
"defrecord" -> "let";
"ns-unmap" -> "the-ns";
"expand-method-impl-cache" -> "inc";
"biginteger" -> "decimal?";
"some->>" -> "apply";
"partition" -> "=";
"min-key" -> "defn";
"asm-type" -> "the-class";
"re-find" -> "re-groups";
"reduce-kv" -> "kv-reduce";
"for" -> "list";
"print-sequential" -> "dec";
"biginteger" -> "defn";
"take-while" -> "cons";
"load-libs" -> "libspec?";
"letfn" -> "list";
"load-lib" -> "apply";
"some-fn" -> "let";
"defrecord" -> "*ns*";
"generate-proxy" -> "let";
"import" -> "fn";
"dissoc!" -> "key";
"symbol?" -> "instance?";
"ns" -> "conj";
"with-bindings" -> "seq";
"for" -> "assert-args";
"is-runtime-annotation?" -> "when-let";
"definline" -> "concat";
"assoc!" -> "let";
"identity" -> "defn";
"with-local-vars" -> "seq";
"proxy-mappings" -> "defn";
"generate-proxy" -> "dotimes";
"destructure" -> "assoc";
"some->" -> "fn";
"print-sequential" -> "*print-dup*";
"println-str" -> "apply";
"await-for" -> "*agent*";
"amap" -> "aset";
"pmap" -> "cons";
"read-line" -> "*in*";
"max" -> "defn";
">" -> "defn";
"the-class" -> "prim->class";
"future-call" -> "deref";
"format" -> "to-array";
"generate-class" -> "when";
"re-groups" -> "loop";
"find-protocol-impl" -> "disj";
"with-out-str" -> "let";
"prep-ints" -> "maybe-min-hash";
"struct-map" -> "defn";
"refer" -> "=";
"emit-extend-type" -> "concat";
"generate-interface" -> "map";
"->Vec" -> "every?";
"locking" -> "defmacro";
"find-ns" -> "defn";
"derive" -> "not=";
"ns" -> "assoc";
"if-not" -> "list";
"spread" -> "nil?";
"emit-defrecord" -> "get";
"take-while" -> "first";
"areduce" -> "apply";
"remove-all-methods" -> "defn";
"destructure" -> "map";
"print-ctor" -> "class";
"even?" -> "str";
"ns-interns" -> "fn";
"ns-publics" -> "the-ns";
"sigs" -> "with-meta";
"merge-with" -> "contains?";
"-reset-methods" -> "doseq";
"keep" -> "lazy-seq";
"ns-imports" -> "filter-key";
"group-by" -> "reduce";
"ns-unalias" -> "the-ns";
"shorts" -> "list";
"memfn" -> "concat";
"extend" -> "doseq";
"fn" -> "list*";
"prep-ints" -> "int";
"memfn" -> "vector";
"build-positional-factory" -> "concat";
"load-data-readers" -> "alter-var-root";
"filterv" -> "fn";
"unchecked-divide-int" -> "defn";
"nthnext" -> "pos?";
"pmap" -> "first";
"agent-errors" -> "when-let";
"filter-methods" -> "concat";
"normalize-slurp-opts" -> "println";
"mk-bound-fn" -> "..";
"println-str" -> "println";
"build-positional-factory" -> "vector";
"*'" -> "defn";
"mod" -> "pos?";
"parse-opts+specs" -> "vec";
"into" -> "conj!";
"gen-class" -> "partition";
"ns" -> "map";
"trampoline" -> "apply";
"if-let" -> "=";
"longs" -> "list";
"mapcat" -> "concat";
"definline" -> "assoc";
"assert-same-protocol" -> "str";
"assert-valid-fdecl" -> "vector?";
"parse-opts+specs" -> "concat";
"load-lib" -> "int";
"filter" -> "chunk-cons";
"set-validator!" -> "defn";
"take" -> "rest";
"definterface" -> "namespace-munge";
"into1" -> "persistent!";
"load-string" -> "->";
"defmacro" -> "defn";
"maybe-min-hash" -> "bit-shift-left";
"case" -> "condp";
"ns-publics" -> "val";
"send-via" -> "binding";
"defstruct" -> "keys";
"when-first" -> "concat";
"fits-table?" -> "-";
"spread" -> "cond";
"extend-protocol" -> "defmacro";
"tree-seq" -> "defn";
"defmacro" -> "map?";
"aset-short" -> "def-aset";
"pr" -> "if-let";
"when-first" -> "vector";
"as->" -> "seq";
"range" -> "defn";
"clojure-version" -> "pos?";
"drop" -> "pos?";
"load-one" -> "dosync";
"select-keys" -> "let";
"make-array" -> "aset-int";
"resultset-seq" -> "inc";
"var-get" -> "defn";
"time" -> "list";
"unchecked-float" -> "defn";
"butlast" -> "loop";
"slurp" -> "reader";
"bound-fn" -> "list";
"destructure" -> "vector?";
"or" -> "seq";
"next" -> "fn";
"assert" -> "when-not";
"prep-hashes" -> "zero?";
"namespace-munge" -> "str";
"emit-defrecord" -> "contains?";
"if-let" -> "defmacro";
"assert-valid-fdecl" -> "map";
"file-seq" -> "seq";
"EMPTY-NODE" -> "object-array";
"some->" -> "repeat";
"every-pred" -> "boolean";
"memoize" -> "defn";
"->>" -> "next";
"import" -> "let";
"<=" -> "first";
"deftype" -> "str";
"refer" -> "find-ns";
"=" -> "defn";
"macroexpand" -> "macroexpand-1";
"the-class" -> "contains?";
"bound-fn*" -> "with-bindings*";
"emit-protocol" -> "defonce";
"bean" -> "defn";
"juxt" -> "apply";
"use" -> "apply";
"await-for" -> "io!";
"proxy-name" -> "inc";
"reify" -> "methods";
"butlast" -> "next";
"print-str" -> "print";
"doto" -> "seq?";
"extend-type" -> "emit-extend-type";
"imap-cons" -> "first";
"chars" -> "concat";
"condp" -> "seq";
"some->" -> "let";
"emit-defrecord" -> "and";
"aget" -> "get";
"defn-" -> "assoc";
"deliver" -> "promise";
"->Vec" -> "meta";
"loop" -> "fn";
"reverse" -> "reduce1";
"pvalues" -> "map";
"not-every?" -> "comp";
"find-protocol-method" -> "find-protocol-impl";
"partition-all" -> "when-let";
"not=" -> "not";
"doseq" -> "chunked-seq?";
"constantly" -> "defn";
"generate-class" -> "merge";
"parse-opts" -> "assoc";
"load-one" -> "commute";
"expand-method-impl-cache" -> "aset";
"filter-key" -> "seq";
"emit-protocol" -> "hash-map";
"merge-hash-collisions" -> "defn-";
"most-specific" -> "or";
"get-proxy-class" -> "proxy-name";
"ns-imports" -> "defn";
"find-field" -> "or";
"for" -> "keyword?";
"doto" -> "concat";
"loop" -> "let";
"range" -> "count";
"future" -> "with-meta";
"dotimes" -> "second";
"min-key" -> "<";
"str" -> "defn";
"doto" -> "vector";
"pr-on" -> "print-dup";
"seque" -> "send-off";
"overload-name" -> "interleave";
"add-doc-and-meta" -> "concat";
"agent" -> "hash-map";
"partition-all" -> "cons";
"with-precision" -> "seq";
"->VecSeq" -> "or";
"emit-defrecord" -> "apply";
"definline" -> "vector?";
"re-matches" -> "let";
"var-set" -> "defn";
"ns-interns" -> "let";
"proxy-call-with-super" -> "let";
"slurp" -> "neg?";
"assert" -> "concat";
"defn" -> "name";
"data-reader-urls" -> "defn-";
"for" -> "chunked-seq?";
"macroexpand" -> "defn";
"cond->>" -> "list";
"zipmap" -> "keys";
"ancestors" -> "supers";
"seque" -> "identical?";
"binding" -> "hash-map";
"resolve" -> "ns-resolve";
"generate-class" -> "meta";
"defmulti" -> "get";
"emit-defrecord" -> "reify";
"await-for" -> "when";
"drop-while" -> "lazy-seq";
"parents" -> "global-hierarchy";
"proxy-super" -> "concat";
"proxy-super" -> "vector";
"reductions" -> "seq";
"pmap" -> "identity";
"replace" -> "reduce1";
"is-runtime-annotation?" -> "=";
"bean" -> "count";
"proxy" -> "resolve";
"range" -> "comp";
"derive" -> "fn";
"->Vec" -> "val";
"emit-defrecord" -> "keyword";
"nthnext" -> "and";
"booleans" -> "list";
"filter-methods" -> "conj";
"find-protocol-impl" -> "remove";
"generate-proxy" -> "loop";
"filter" -> "chunk-append";
"overload-name" -> "str";
"deftype" -> "defmacro";
"interleave" -> "defn";
"escape-class-name" -> "defn-";
"emit-protocol" -> "when";
"ns-publics" -> "instance?";
"take" -> "dec";
"reduce" -> "defn";
">=" -> "first";
"expand-method-impl-cache" -> "reduce1";
"denominator" -> "defn";
"as->" -> "name";
"peek" -> "defn";
"make-array" -> "int";
"cycle" -> "defn";
"filter-key" -> "key";
"merge" -> "when";
"sorted?" -> "instance?";
"keep" -> "chunk-first";
"mk-am" -> "apply";
"sigs" -> "seq?";
"agent" -> "when";
"doseq" -> "keyword?";
"loaded-libs" -> "*loaded-libs*";
"mapv" -> "fn";
"bean" -> "when-let";
"last" -> "next";
"print-sequential" -> "when";
"case" -> "count";
"generate-proxy" -> "next";
"symbol" -> "symbol?";
"sort-by" -> "defn";
"drop" -> "and";
"<" -> "defn";
"defonce" -> "apply";
"rationalize" -> "defn";
"filter-methods" -> "assoc";
"pr-str" -> "defn";
"assoc-in" -> "assoc";
"->Vec" -> "object-array";
"seque" -> "when-not";
"keep-indexed" -> "+";
"import" -> "symbol?";
"mk-am" -> "reify";
"namespace" -> "defn";
"supers" -> "first";
"load" -> "defn";
"ref" -> "setup-reference";
"libspec?" -> "symbol?";
"generate-interface" -> "defn-";
"sorted-map"[label="sorted-map"];
"read-line"[label="read-line"];
"re-pattern"[label="re-pattern"];
"cond->>"[label="cond->>"];
"keyword?"[label="keyword?"];
"asm-type"[label="asm-type"];
"system-newline"[label="system-newline"];
"unchecked-inc-int"[label="unchecked-inc-int"];
"val"[label="val"];
"chunked-seq?"[label="chunked-seq?"];
"find-protocol-impl"[label="find-protocol-impl"];
"vector-of"[label="vector-of"];
"object-array"[label="object-array"];
"*compile-path*"[label="*compile-path*"];
"max-key"[label="max-key"];
"list*"[label="list*"];
"ns-aliases"[label="ns-aliases"];
"booleans"[label="booleans"];
"the-ns"[label="the-ns"];
"=="[label="=="];
"chunk-buffer"[label="chunk-buffer"];
"generate-class"[label="generate-class"];
"longs"[label="longs"];
"process-annotation"[label="process-annotation"];
"shorts"[label="shorts"];
"data-reader-var"[label="data-reader-var"];
"is-annotation?"[label="is-annotation?"];
"instance?"[label="instance?"];
">0?"[label=">0?"];
"format"[label="format"];
"sequential?"[label="sequential?"];
"fn?"[label="fn?"];
"empty"[label="empty"];
"bound-fn"[label="bound-fn"];
"dorun"[label="dorun"];
"time"[label="time"];
"remove-method"[label="remove-method"];
"gensym"[label="gensym"];
"not="[label="not="];
"*3"[label="*3"];
"load-data-readers"[label="load-data-readers"];
"pref"[label="pref"];
"unchecked-multiply"[label="unchecked-multiply"];
"doseq"[label="doseq"];
"bit-or"[label="bit-or"];
"aset-byte"[label="aset-byte"];
"if-not"[label="if-not"];
"send-via"[label="send-via"];
"hash-set"[label="hash-set"];
"->Vec"[label="->Vec"];
"add-watch"[label="add-watch"];
"unchecked-dec"[label="unchecked-dec"];
"some"[label="some"];
"nil?"[label="nil?"];
"string?"[label="string?"];
"boolean-array"[label="boolean-array"];
"second"[label="second"];
"letfn"[label="letfn"];
"keys"[label="keys"];
"for"[label="for"];
"*2"[label="*2"];
"long-array"[label="long-array"];
"pop-thread-bindings"[label="pop-thread-bindings"];
"check-valid-options"[label="check-valid-options"];
"error-mode"[label="error-mode"];
"cond"[label="cond"];
"bit-set"[label="bit-set"];
"spit"[label="spit"];
"find-protocol-method"[label="find-protocol-method"];
"fn"[label="fn"];
"sorted?"[label="sorted?"];
"short-array"[label="short-array"];
"ns-unalias"[label="ns-unalias"];
"ns-publics"[label="ns-publics"];
"EMPTY-NODE"[label="EMPTY-NODE"];
"char-array"[label="char-array"];
"dosync"[label="dosync"];
"all-ns"[label="all-ns"];
"long"[label="long"];
"with-open"[label="with-open"];
"init-proxy"[label="init-proxy"];
"add-classpath"[label="add-classpath"];
"false?"[label="false?"];
"await1"[label="await1"];
"true?"[label="true?"];
"gen-interface"[label="gen-interface"];
"sync"[label="sync"];
"emit-extend-protocol"[label="emit-extend-protocol"];
"short"[label="short"];
"ns-unmap"[label="ns-unmap"];
"protected-final-methods"[label="protected-final-methods"];
"repeat"[label="repeat"];
"zipmap"[label="zipmap"];
"distinct"[label="distinct"];
"get-in"[label="get-in"];
"bit-xor"[label="bit-xor"];
"char-escape-string"[label="char-escape-string"];
"complement"[label="complement"];
"let"[label="let"];
"get-validator"[label="get-validator"];
"dotimes"[label="dotimes"];
"ref-max-history"[label="ref-max-history"];
"*ns*"[label="*ns*"];
"promise"[label="promise"];
"defmethod"[label="defmethod"];
"set-agent-send-executor!"[label="set-agent-send-executor!"];
"protocol?"[label="protocol?"];
"-'"[label="-'"];
"pop!"[label="pop!"];
"derive"[label="derive"];
"aset-float"[label="aset-float"];
"valid-java-method-name"[label="valid-java-method-name"];
"extend"[label="extend"];
"-reset-methods"[label="-reset-methods"];
"lazy-cat"[label="lazy-cat"];
"commute"[label="commute"];
"defstruct"[label="defstruct"];
"with-in-str"[label="with-in-str"];
"partition-by"[label="partition-by"];
"rem"[label="rem"];
"odd?"[label="odd?"];
"symbol?"[label="symbol?"];
"mapv"[label="mapv"];
"*print-level*"[label="*print-level*"];
"*allow-unresolved-vars*"[label="*allow-unresolved-vars*"];
"thread-bound?"[label="thread-bound?"];
"*data-readers*"[label="*data-readers*"];
"deref-future"[label="deref-future"];
"root-resource"[label="root-resource"];
"filterv"[label="filterv"];
"proxy-call-with-super"[label="proxy-call-with-super"];
"*unchecked-math*"[label="*unchecked-math*"];
"ns-interns"[label="ns-interns"];
"re-matches"[label="re-matches"];
"split-with"[label="split-with"];
"munge"[label="munge"];
"loop"[label="loop"];
"future-done?"[label="future-done?"];
"spread"[label="spread"];
"next"[label="next"];
"writer"[label="writer"];
"import"[label="import"];
"print-meta"[label="print-meta"];
"deliver"[label="deliver"];
"symbol"[label="symbol"];
"vals"[label="vals"];
"->ArrayChunk"[label="->ArrayChunk"];
"select-keys"[label="select-keys"];
"re-matcher"[label="re-matcher"];
"rand"[label="rand"];
"deref"[label="deref"];
"load-one"[label="load-one"];
"some->"[label="some->"];
"unchecked-inc"[label="unchecked-inc"];
"libspec?"[label="libspec?"];
"*math-context*"[label="*math-context*"];
"read"[label="read"];
"sequence"[label="sequence"];
"make-hierarchy"[label="make-hierarchy"];
"+"[label="+"];
"number?"[label="number?"];
"assoc!"[label="assoc!"];
"descendants"[label="descendants"];
"generate-proxy"[label="generate-proxy"];
"into-array"[label="into-array"];
"last"[label="last"];
"some-fn"[label="some-fn"];
"unchecked-negate"[label="unchecked-negate"];
"integer?"[label="integer?"];
"defrecord"[label="defrecord"];
"reduced?"[label="reduced?"];
"*read-eval*"[label="*read-eval*"];
"alter"[label="alter"];
"prn"[label="prn"];
"with-meta"[label="with-meta"];
"with-out-str"[label="with-out-str"];
"floats"[label="floats"];
"*"[label="*"];
"*compile-files*"[label="*compile-files*"];
"emit-hinted-impl"[label="emit-hinted-impl"];
"when-not"[label="when-not"];
"butlast"[label="butlast"];
"-"[label="-"];
"->>"[label="->>"];
"reversible?"[label="reversible?"];
"rseq"[label="rseq"];
"send-off"[label="send-off"];
"seq?"[label="seq?"];
"refer-clojure"[label="refer-clojure"];
"identical?"[label="identical?"];
".."[label=".."];
"print"[label="print"];
"vary-meta"[label="vary-meta"];
"with-loading-context"[label="with-loading-context"];
"agent-error"[label="agent-error"];
"*command-line-args*"[label="*command-line-args*"];
"bit-flip"[label="bit-flip"];
"zero?"[label="zero?"];
"bit-and"[label="bit-and"];
"load-data-reader-file"[label="load-data-reader-file"];
"unquote-splicing"[label="unquote-splicing"];
"future"[label="future"];
"re-groups"[label="re-groups"];
"*warn-on-reflection*"[label="*warn-on-reflection*"];
"reader"[label="reader"];
"newline"[label="newline"];
"replicate"[label="replicate"];
"keep-indexed"[label="keep-indexed"];
"char?"[label="char?"];
"def-aset"[label="def-aset"];
"distinct?"[label="distinct?"];
"remove-ns"[label="remove-ns"];
"ratio?"[label="ratio?"];
"xml-seq"[label="xml-seq"];
"vec"[label="vec"];
"concat"[label="concat"];
"update-in"[label="update-in"];
"vector"[label="vector"];
"sigs"[label="sigs"];
"with-bindings*"[label="with-bindings*"];
"conj"[label="conj"];
"bases"[label="bases"];
"with-redefs"[label="with-redefs"];
"root-directory"[label="root-directory"];
"/"[label="/"];
"unchecked-add"[label="unchecked-add"];
"ref-set"[label="ref-set"];
"assoc"[label="assoc"];
"unchecked-remainder-int"[label="unchecked-remainder-int"];
"seque"[label="seque"];
"load-libs"[label="load-libs"];
"aset-char"[label="aset-char"];
"boolean"[label="boolean"];
"read-string"[label="read-string"];
"binding-conveyor-fn"[label="binding-conveyor-fn"];
"neg?"[label="neg?"];
"float-array"[label="float-array"];
"doubles"[label="doubles"];
"isa?"[label="isa?"];
"future-call"[label="future-call"];
"doto"[label="doto"];
"extends?"[label="extends?"];
"fits-table?"[label="fits-table?"];
"remove-watch"[label="remove-watch"];
"print-str"[label="print-str"];
"*e"[label="*e"];
"ref-history-count"[label="ref-history-count"];
"rsubseq"[label="rsubseq"];
"*flush-on-newline*"[label="*flush-on-newline*"];
"*out*"[label="*out*"];
"future?"[label="future?"];
"vector?"[label="vector?"];
"prep-hashes"[label="prep-hashes"];
"split-at"[label="split-at"];
"chunk-cons"[label="chunk-cons"];
"ns-refers"[label="ns-refers"];
"create-struct"[label="create-struct"];
"setup-reference"[label="setup-reference"];
"proxy-super"[label="proxy-super"];
"int-array"[label="int-array"];
"unchecked-long"[label="unchecked-long"];
"float"[label="float"];
"mk-bound-fn"[label="mk-bound-fn"];
"assert"[label="assert"];
"map"[label="map"];
"+'"[label="+'"];
"add-doc-and-meta"[label="add-doc-and-meta"];
"counted?"[label="counted?"];
"memfn"[label="memfn"];
"double-array"[label="double-array"];
"ams"[label="ams"];
"accessor"[label="accessor"];
"*print-length*"[label="*print-length*"];
"frequencies"[label="frequencies"];
"chars"[label="chars"];
"class?"[label="class?"];
"rand-int"[label="rand-int"];
"*1"[label="*1"];
"aset-short"[label="aset-short"];
"unchecked-short"[label="unchecked-short"];
"prn-str"[label="prn-str"];
"iterate"[label="iterate"];
"chunk-append"[label="chunk-append"];
"when-first"[label="when-first"];
"unchecked-double"[label="unchecked-double"];
"parse-opts"[label="parse-opts"];
"slurp"[label="slurp"];
"restart-agent"[label="restart-agent"];
"parse-opts+specs"[label="parse-opts+specs"];
"unchecked-int"[label="unchecked-int"];
"mapcat"[label="mapcat"];
"assoc-in"[label="assoc-in"];
"get-thread-bindings"[label="get-thread-bindings"];
"filter-methods"[label="filter-methods"];
"build-positional-factory"[label="build-positional-factory"];
"special-symbol?"[label="special-symbol?"];
"ref"[label="ref"];
"conj!"[label="conj!"];
"find-var"[label="find-var"];
"inc"[label="inc"];
"future-cancel"[label="future-cancel"];
"emit-extend-type"[label="emit-extend-type"];
"every-pred"[label="every-pred"];
"definline"[label="definline"];
"bound-fn*"[label="bound-fn*"];
"default-data-readers"[label="default-data-readers"];
"unchecked-subtract"[label="unchecked-subtract"];
"ns-name"[label="ns-name"];
"shuffle"[label="shuffle"];
"defn-"[label="defn-"];
"*file*"[label="*file*"];
"re-find"[label="re-find"];
"bit-not"[label="bit-not"];
"construct-proxy"[label="construct-proxy"];
"ref-min-history"[label="ref-min-history"];
"destructure"[label="destructure"];
"seq"[label="seq"];
"intern"[label="intern"];
"unchecked-multiply-int"[label="unchecked-multiply-int"];
"pvalues"[label="pvalues"];
"add-annotations"[label="add-annotations"];
"to-array-2d"[label="to-array-2d"];
"sorted-map-by"[label="sorted-map-by"];
"filter"[label="filter"];
"->VecNode"[label="->VecNode"];
"*verbose-defrecords*"[label="*verbose-defrecords*"];
"assert-valid-fdecl"[label="assert-valid-fdecl"];
"*clojure-version*"[label="*clojure-version*"];
"var?"[label="var?"];
"alter-meta!"[label="alter-meta!"];
"unchecked-dec-int"[label="unchecked-dec-int"];
"print-object"[label="print-object"];
"comment"[label="comment"];
"key"[label="key"];
"class"[label="class"];
"re-seq"[label="re-seq"];
"-cache-protocol-fn"[label="-cache-protocol-fn"];
"ns"[label="ns"];
"empty?"[label="empty?"];
"test"[label="test"];
"print-dup"[label="print-dup"];
"create-ns"[label="create-ns"];
"merge-hash-collisions"[label="merge-hash-collisions"];
"generate-interface"[label="generate-interface"];
"name"[label="name"];
"list?"[label="list?"];
"reduce1"[label="reduce1"];
"global-hierarchy"[label="global-hierarchy"];
"escape-class-name"[label="escape-class-name"];
"nthrest"[label="nthrest"];
"nary-inline"[label="nary-inline"];
"aset"[label="aset"];
"nnext"[label="nnext"];
"doall"[label="doall"];
"extenders"[label="extenders"];
"data-reader-urls"[label="data-reader-urls"];
"macroexpand-1"[label="macroexpand-1"];
"not-any?"[label="not-any?"];
"resultset-seq"[label="resultset-seq"];
"reductions"[label="reductions"];
"pr-on"[label="pr-on"];
"into"[label="into"];
"with-precision"[label="with-precision"];
"*use-context-classloader*"[label="*use-context-classloader*"];
"transient"[label="transient"];
"filter-key"[label="filter-key"];
"ffirst"[label="ffirst"];
"bit-clear"[label="bit-clear"];
"proxy-name"[label="proxy-name"];
"extend-type"[label="extend-type"];
"load-reader"[label="load-reader"];
"with-redefs-fn"[label="with-redefs-fn"];
"or"[label="or"];
"hash"[label="hash"];
"as->"[label="as->"];
"inc'"[label="inc'"];
"print-initialized"[label="print-initialized"];
"expand-method-impl-cache"[label="expand-method-impl-cache"];
"print-ctor"[label="print-ctor"];
"associative?"[label="associative?"];
"float?"[label="float?"];
"drop-last"[label="drop-last"];
"replace"[label="replace"];
"decimal?"[label="decimal?"];
"defn"[label="defn"];
"parents"[label="parents"];
"map?"[label="map?"];
"prefers"[label="prefers"];
"numerator"[label="numerator"];
"condp"[label="condp"];
"quot"[label="quot"];
"chunk-rest"[label="chunk-rest"];
"unchecked-negate-int"[label="unchecked-negate-int"];
"file-seq"[label="file-seq"];
"send"[label="send"];
"with-local-vars"[label="with-local-vars"];
"reverse"[label="reverse"];
"validate-generate-class-options"[label="validate-generate-class-options"];
"with-bindings"[label="with-bindings"];
"count"[label="count"];
"kv-reduce"[label="kv-reduce"];
"get-proxy-class"[label="get-proxy-class"];
"set"[label="set"];
"ex-info"[label="ex-info"];
"unchecked-subtract-int"[label="unchecked-subtract-int"];
"when-let"[label="when-let"];
"comp"[label="comp"];
"nth"[label="nth"];
"byte"[label="byte"];
"dissoc!"[label="dissoc!"];
"*err*"[label="*err*"];
"implements?"[label="implements?"];
"constantly"[label="constantly"];
"load"[label="load"];
"namespace"[label="namespace"];
"pr-str"[label="pr-str"];
"<"[label="<"];
"rationalize"[label="rationalize"];
"sort-by"[label="sort-by"];
"->VecSeq"[label="->VecSeq"];
"cycle"[label="cycle"];
"peek"[label="peek"];
"denominator"[label="denominator"];
"find-field"[label="find-field"];
"most-specific"[label="most-specific"];
"reduce"[label="reduce"];
"interleave"[label="interleave"];
"print-map"[label="print-map"];
"amap"[label="amap"];
"->"[label="->"];
"cons"[label="cons"];
"macroexpand"[label="macroexpand"];
"ctor-sigs"[label="ctor-sigs"];
"var-set"[label="var-set"];
"add-annotation"[label="add-annotation"];
"str"[label="str"];
"aset-boolean"[label="aset-boolean"];
"ns-imports"[label="ns-imports"];
"while"[label="while"];
"coll-reduce"[label="coll-reduce"];
"remove-all-methods"[label="remove-all-methods"];
"first"[label="first"];
"bean"[label="bean"];
"="[label="="];
"memoize"[label="memoize"];
"max-switch-table-size"[label="max-switch-table-size"];
"var-get"[label="var-get"];
"unchecked-float"[label="unchecked-float"];
"range"[label="range"];
"tree-seq"[label="tree-seq"];
"defmacro"[label="defmacro"];
"set-validator!"[label="set-validator!"];
"aset-double"[label="aset-double"];
"check-cyclic-dependency"[label="check-cyclic-dependency"];
"*'"[label="*'"];
"case"[label="case"];
"unchecked-divide-int"[label="unchecked-divide-int"];
"emit-impl"[label="emit-impl"];
"enumeration-seq"[label="enumeration-seq"];
"prefer-method"[label="prefer-method"];
"partition-all"[label="partition-all"];
"ensure"[label="ensure"];
"reduced"[label="reduced"];
"find-ns"[label="find-ns"];
"not-every?"[label="not-every?"];
"struct-map"[label="struct-map"];
">"[label=">"];
"max"[label="max"];
"proxy-mappings"[label="proxy-mappings"];
"identity"[label="identity"];
"*loaded-libs*"[label="*loaded-libs*"];
"ints"[label="ints"];
"fnext"[label="fnext"];
"biginteger"[label="biginteger"];
"min-key"[label="min-key"];
"reset-meta!"[label="reset-meta!"];
"array"[label="array"];
"push-thread-bindings"[label="push-thread-bindings"];
"unchecked-add-int"[label="unchecked-add-int"];
"subs"[label="subs"];
"compile"[label="compile"];
"throw-if"[label="throw-if"];
"agent-errors"[label="agent-errors"];
"clear-agent-errors"[label="clear-agent-errors"];
"printf"[label="printf"];
"overload-name"[label="overload-name"];
"ns-resolve"[label="ns-resolve"];
"method-sig"[label="method-sig"];
"*default-data-reader-fn*"[label="*default-data-reader-fn*"];
">="[label=">="];
"assert-same-protocol"[label="assert-same-protocol"];
"shutdown-agents"[label="shutdown-agents"];
"reduce-kv"[label="reduce-kv"];
"reset!"[label="reset!"];
"is-runtime-annotation?"[label="is-runtime-annotation?"];
"case-map"[label="case-map"];
"even?"[label="even?"];
"require"[label="require"];
"bit-shift-left"[label="bit-shift-left"];
"dec'"[label="dec'"];
"methods"[label="methods"];
"future-cancelled?"[label="future-cancelled?"];
"compare"[label="compare"];
"deftype"[label="deftype"];
"sorted-set-by"[label="sorted-set-by"];
"cast"[label="cast"];
"namespace-munge"[label="namespace-munge"];
"supers"[label="supers"];
"pcalls"[label="pcalls"];
"load-string"[label="load-string"];
"group-by"[label="group-by"];
"get"[label="get"];
"<="[label="<="];
"await"[label="await"];
"resolve"[label="resolve"];
"bytes"[label="bytes"];
"print-method"[label="print-method"];
"bound?"[label="bound?"];
"loaded-libs"[label="loaded-libs"];
"fnil"[label="fnil"];
"force"[label="force"];
"partial"[label="partial"];
">1?"[label=">1?"];
"pmap"[label="pmap"];
"if-let"[label="if-let"];
"comparator"[label="comparator"];
"pos?"[label="pos?"];
"prim->class"[label="prim->class"];
"char"[label="char"];
"take-while"[label="take-while"];
"*loading-verbosely*"[label="*loading-verbosely*"];
"extend-protocol"[label="extend-protocol"];
"imap-cons"[label="imap-cons"];
"and"[label="and"];
"refer"[label="refer"];
"underive"[label="underive"];
"in-ns"[label="in-ns"];
"iterator-seq"[label="iterator-seq"];
"declare"[label="declare"];
"ancestors"[label="ancestors"];
"hash-combine"[label="hash-combine"];
"persistent!"[label="persistent!"];
"locking"[label="locking"];
"partition"[label="partition"];
"maybe-destructured"[label="maybe-destructured"];
"map-indexed"[label="map-indexed"];
"contains?"[label="contains?"];
"update-proxy"[label="update-proxy"];
"shift-mask"[label="shift-mask"];
"interpose"[label="interpose"];
"chunk"[label="chunk"];
"aset-int"[label="aset-int"];
"emit-method-builder"[label="emit-method-builder"];
"ifn?"[label="ifn?"];
"definterface"[label="definterface"];
"load-file"[label="load-file"];
"group-by-sig"[label="group-by-sig"];
"delay"[label="delay"];
"apply"[label="apply"];
"swap!"[label="swap!"];
"defmulti"[label="defmulti"];
"proxy"[label="proxy"];
"reify"[label="reify"];
"subvec"[label="subvec"];
"byte-array"[label="byte-array"];
"rest"[label="rest"];
"keyword"[label="keyword"];
"prependss"[label="prependss"];
"ns-map"[label="ns-map"];
"set-error-mode!"[label="set-error-mode!"];
"maybe-min-hash"[label="maybe-min-hash"];
"unquote"[label="unquote"];
"super-chain"[label="super-chain"];
"int"[label="int"];
"release-pending-sends"[label="release-pending-sends"];
"mod"[label="mod"];
"bigdec"[label="bigdec"];
"nfirst"[label="nfirst"];
"nthnext"[label="nthnext"];
"descriptor"[label="descriptor"];
"*agent*"[label="*agent*"];
"aset-long"[label="aset-long"];
"non-private-methods"[label="non-private-methods"];
"struct"[label="struct"];
"array-map"[label="array-map"];
"unchecked-char"[label="unchecked-char"];
"bigint"[label="bigint"];
"dec"[label="dec"];
"println"[label="println"];
"aget"[label="aget"];
"find-keyword"[label="find-keyword"];
"pr"[label="pr"];
"drop"[label="drop"];
"clojure-version"[label="clojure-version"];
"*print-dup*"[label="*print-dup*"];
"gen-class"[label="gen-class"];
"eval"[label="eval"];
"aclone"[label="aclone"];
"char-name-string"[label="char-name-string"];
"pop"[label="pop"];
"primitives-classnames"[label="primitives-classnames"];
"atom"[label="atom"];
"defonce"[label="defonce"];
"bit-shift-right"[label="bit-shift-right"];
"*pending-paths*"[label="*pending-paths*"];
"mk-am"[label="mk-am"];
"delay?"[label="delay?"];
"num"[label="num"];
"realized?"[label="realized?"];
"disj"[label="disj"];
"io!"[label="io!"];
"*print-readably*"[label="*print-readably*"];
"rational?"[label="rational?"];
"merge-with"[label="merge-with"];
"take-nth"[label="take-nth"];
"*fn-loader*"[label="*fn-loader*"];
"into1"[label="into1"];
"*print-meta*"[label="*print-meta*"];
"the-class"[label="the-class"];
"double"[label="double"];
"lazy-seq"[label="lazy-seq"];
"*in*"[label="*in*"];
"emit-defrecord"[label="emit-defrecord"];
"take-last"[label="take-last"];
"line-seq"[label="line-seq"];
"take"[label="take"];
"unchecked-byte"[label="unchecked-byte"];
"when"[label="when"];
"load-all"[label="load-all"];
"areduce"[label="areduce"];
"set?"[label="set?"];
"make-array"[label="make-array"];
"rand-nth"[label="rand-nth"];
"alias"[label="alias"];
"use"[label="use"];
"juxt"[label="juxt"];
"alength"[label="alength"];
"chunk-first"[label="chunk-first"];
"*source-path*"[label="*source-path*"];
"defprotocol"[label="defprotocol"];
"to-array"[label="to-array"];
"hash-map"[label="hash-map"];
"bit-and-not"[label="bit-and-not"];
"*compiler-options*"[label="*compiler-options*"];
"compare-and-set!"[label="compare-and-set!"];
"*assert*"[label="*assert*"];
"type"[label="type"];
"repeatedly"[label="repeatedly"];
"trampoline"[label="trampoline"];
"set-error-handler!"[label="set-error-handler!"];
"validate-fields"[label="validate-fields"];
"remove"[label="remove"];
"find"[label="find"];
"coll?"[label="coll?"];
"drop-while"[label="drop-while"];
"parse-impls"[label="parse-impls"];
"not-empty"[label="not-empty"];
"flatten"[label="flatten"];
"ex-data"[label="ex-data"];
"set-agent-send-off-executor!"[label="set-agent-send-off-executor!"];
"normalize-slurp-opts"[label="normalize-slurp-opts"];
"println-str"[label="println-str"];
"list"[label="list"];
"get-super-and-interfaces"[label="get-super-and-interfaces"];
"chunk-next"[label="chunk-next"];
"every?"[label="every?"];
"satisfies?"[label="satisfies?"];
"flush"[label="flush"];
"assert-args"[label="assert-args"];
"load-lib"[label="load-lib"];
"max-mask-bits"[label="max-mask-bits"];
"some->>"[label="some->>"];
"sort"[label="sort"];
"prep-ints"[label="prep-ints"];
"dissoc"[label="dissoc"];
"cond->"[label="cond->"];
"not"[label="not"];
"binding"[label="binding"];
"print-sequential"[label="print-sequential"];
"error-handler"[label="error-handler"];
"get-method"[label="get-method"];
"agent"[label="agent"];
"sorted-set"[label="sorted-set"];
"alter-var-root"[label="alter-var-root"];
"merge"[label="merge"];
"subseq"[label="subseq"];
"emit-protocol"[label="emit-protocol"];
"min"[label="min"];
"print-simple"[label="print-simple"];
"bit-test"[label="bit-test"];
"await-for"[label="await-for"];
"keep"[label="keep"];
"disj!"[label="disj!"];
"meta"[label="meta"];
"emit-deftype*"[label="emit-deftype*"];
}